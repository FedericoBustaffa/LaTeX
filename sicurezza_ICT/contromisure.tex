\chapter{Contromisure}
Quando parliamo di \textbf{contromisure} facciamo riferimento a delle modifiche che il difensore fa al sistema in
risposta alle intrusioni. Una prima classificazione delle contromisure le divide in tre grandi categorie:
\begin{itemize}
	\item \textbf{Proattive}: Applicate prima di un'intrusione per impedirla.
	\item \textbf{Dinamiche}: Applicate durante un'intrusione per fermarla.
	\item \textbf{Reattive}: Applicate dopo un'intrusione per fermare quelle successive.
\end{itemize}
Il processo per l'eliminazione delle vulnerabilità prevede i seguenti passi:
\begin{enumerate}
	\item Prevenire
	\item Resistere
	\item Scoprire
	\item Ripristinare
	\item Reagire
\end{enumerate}

\section{Robustezza e resilienza}
Due punti cardine della sicurezza sono \textbf{robustezza} e \textbf{resilienza}.

Per \emph{robustezza} si intende la capacità di un sistema di \emph{respingere} le intrusioni ma nel caso in cui il
sistema venga violato le prestazioni (in termini di sicurezza) calano. La capacità di un sistema di ripristinare la
robustezza dopo un'intrusione è detta \emph{resilienza}.

\subsection{Ridondanza ed eterogeneità}
Due punti importanti su cui si basano i principi di robustezza e resilienza sono \textbf{ridondanza} ed
\textbf{eterogeneità}.

\subsubsection{Ridondanza}
La \emph{ridondanza} si ottiene sovradimensionando il sistema con componenti o procedure \emph{inutili} ai fini di
funzionamento del sistema ma che sono molto utili nel momento in cui il sistema viene attaccato o violato per
resistere all'attacco o ripristinare lo stato sicuro. La ridondanza può essere di vario tipo:
\begin{itemize}
	\item \textbf{Ridondanza fredda}: componenti inattive che vengono attivate solo quando il sistema viene attaccato
	      per riuscire a ripristinare lo stato sicuro.
	\item \textbf{Ridondanza calda}: componenti sempre attive in modo da riuscire a sopportare meglio gli attacchi.
	\item \textbf{Triple Modular Redundancy}: ridondanza calda dove tre copie di uno stesso modulo prendono lo stesso
	      input ed eseguono la stessa computazione \emph{votando} infine il risultato. Aumenta la safety ma non sempre
	      la security.
\end{itemize}

\subsubsection{Eterogeneità}
Per \emph{eterogeneità} si intende l'uso di componenti diversi che svolgono compiti simili per evitare la caduta del
sistema su una singola vulnerabilità. Se un componente ha una vulnerabilità e più nodi del sistema hanno quel
componente, tutti i nodi con quel componente avranno quella vulnerabilità.

Un tipico esempio di eterogeneità è quello in cui si usano sistemi operativi diversi su una stessa rete.

\subsection{Sistema minimale}
Una buona pratica per la sicurezza è quella di costruire un sottoinsieme del sistema, formato da componenti
particolarmente robusti e spesso eterogenei rispetto a quelli del sistema principale.

Il sistema minimale è quello da cui parte il ripristino del normale funzionamento del sistema.

La violazione del sistema minimale comporta l'incapacità di ripristinare il sistema dopo un attacco.

\section{Meccanismi per contromisure}
L'implementazione di contromisure è basata di meccanismi condivisi i quali devono essere molto robusti dato che una
loro vulnerabilità potrebbe influenzare molte contromisure del sistema.

Tali meccanismi sono implementati su un security kernel che fa parte del TCB e che gestisce: l'\textbf{identità},
l'\textbf{autenticazione} e i \textbf{diritti} degli utenti.

\subsection{Autenticazione}
Per implementare un buon meccanismo di autenticazione si fa sempre riferimento alla tripla
\begin{center}
	\verb|<soggetto, oggetto, operazione>|
\end{center}
la quale associa ad un soggetto un certo diritto. Possiamo associare due tipi di controlli a questa tupla:
\begin{itemize}
	\item Controlli sull'identità del soggetto.
	\item Controlli sul possesso del diritto \verb|<oggetto, operazione>|.
\end{itemize}
Il controllo sul possesso dei diritti dei vari utenti e la loro gestione è compito del sistema operativo. Anche
l'autenticazione è compito del sistema operativo ma attualmente esistono componenti specializzati per l'autenticazione
che forniscono un token in grado di certificare in qualche modo l'avvenuta autenticazione.

\subsubsection{Tipi di autenticazione}
Esistono tre tipi principali di autenticazione:
\begin{itemize}
	\item \textbf{Debole statica}: include password e altre tecniche soggette ad attacchi che cercano di riprodurre
	      le sequenze di autenticazione.
	\item \textbf{Debole non statica}: fa uso di meccanismi crittografici per creare password utilizzabili per una
	      singola sessione. Può essere compromessa da attacchi di tipi \emph{session hijacking}, ossia dal
	      \emph{furto} della sessione.
	\item \textbf{Forte}: utilizza forti meccanismi crittografici per prevenire i principali problemi legati
	      all'autenticazione debole.
\end{itemize}

\subsubsection{Meccanismi di autenticazione}
Tra i meccanismi di autenticazione più comuni abbiamo:
\begin{itemize}
	\item L'utilizzo di frasi o numeri che solo l'utente conosce. Per difendersi da possibili attacchi, in genere si
	      salva un hash di queste informazioni e non l'informazione in chiaro. Un altro metodo consiste nell'uso di
	      database diversi per impedire attacchi che precalcolano l'hash.
	\item L'utilizzo di qualcosa che solo l'utente possiede, come una chiave di cifratura. Con questo metodo di
	      autenticazione si può
	      \begin{itemize}
		      \item Generare il prossima bit di una sequenza pseudocasuale.
		      \item Applicare una funzione condivisa ad un valore ricevuto dal server e restituire il risultato.
	      \end{itemize}
	\item L'utilizzo di parametri biometrici. Questo tipo di autenticazione porta con sé problemi di falsi
	      positivi/negativi, attacchi alla trasmissione di informazioni biometriche e difficoltà nel cambiare la
	      password.
\end{itemize}

\subsubsection{Kerberos}
Il sistema \textbf{Kerberos} permette ad un client di autenticarsi con un server tramite due entità: un \textbf{KDC}
(Key Distribution Center) e un \textbf{TGS}	(Ticket Granting Service).

Il KDC condivide con ogno entità del sistema (client, server e TGS) una chiave di cifratura. Per un client, conoscere
tale chiave equivale ad essere autenticato.

Un client che si connette al sistema deve essere in grado di decifrare qualsiasi cosa cifrata con la chiave che il KDC
gli ha fornito. Dato che il sistema comunica con gli utenti tramite messaggi crittografati, un utente malizioso che si
finge qualcun altro non sarebbe in grado di decifrare tali messaggi e dunque non riuscirebbe ad autenticarsi.

Supponiamo ora che un utente $A$ voglia autenticarsi ad un server tramite Kerberos:
\begin{enumerate}
	\item In una fase preliminare il KDC condivide due chiavi simmetriche $k_{TGS}$ e $k_A$ rispettivamente con il TGS
	      e con $A$.
	\item L'utente $A$ richiede i servizi del server $S$ e fa richiesta al sistema identificandosi come $A$.
	\item Il KDC invia informazioni cifrate con la chiave $k_A$ ad $A$ per interagire con il TGS.
	\item L'utente $A$ decifra le informazioni e le invia al TGS. Ciò che $A$ invia al TGS è cifrato con la chiave
	      del TGS.
	\item Il TGS decifra ciò che $A$ gli ha inviato e se ottiene informazioni consistenti fornisce un ticket di
	      validità temporanea ad $A$.
	\item $A$ usa il ticket per autenticarsi con $S$ ed essere quindi in grado di usufruire dei suoi servizi.
\end{enumerate}
Il KDC e il TGS gestiscono dei database in cui sono memorizzate le \emph{master key} dei client e dei server registrati.
Le \emph{master keys} all'interno del database sono criptate con la chiave privata rispettivamente del KDC e del TGS.
Se qualcuno venisse a conoscenza di queste due chiavi, l'intero sistema sarebbe compromesso.

\subsection{Controllo e gestione dei diritti}
Una volta avvenuta l'autenticazione l'utente è riconosciuto dal sistema ma ciò che può fare all'interno di esso dipende
dai diritti che possiede.

Per controllare quali diritti un soggetto $S_i$ ha nel sistema si fa utilizzo della \textbf{matrice di controllo degli
	accessi}, la quale mette in relazione il soggetto $S_i$ che vuole compiere un'azione e l'oggetto $O_j$ su cui viene
compiuta e ricava i diritti (o operazioni $op_{ij}$) che quel soggetto ha (o può fare) sull'oggetto.
\begin{center}
	\begin{tabular}{ c | c | c | c | c |}
		      & $O_1$ & $O_2$     & \dots     & $O_n$ \\
		\hline
		$S_1$ &       & $op_{12}$ &           &       \\
		\hline
		$S_2$ &       &           &           &       \\
		\hline
		\dots &       &           & $op_{ij}$ &       \\
		\hline
		$S_m$ &       &           &           &       \\
		\hline
	\end{tabular}
\end{center}
In genere una matrice del genere è presente a livello di sistema operativo per protezione di zone di memoria, file,
dispositivi di I/O e porte dei vari protocolli. Possono esserci matrici di controllo anche a livello applicativo per
le specifiche applicazioni nel caso fosse necessario.

In generale la matrice del sistema operativo determina quali utenti possono interagire con un'applicazione. Questo si
può controllare mediante il meccanismo delle porte o dei canali di comunicazione.

Per gli utenti che possono interagire la matrice determina quali operazioni nello specifico possono essere eseguite
sull'oggetto. Se invece un utente non può interagire conviene impedire l'interazione al livello più basso possibile
e scartare la richiesta.

Tutte queste operazioni di controllo comportano un \emph{overhead}, in particolare l'operazione di scarto di una
richiesta e rende il sistema più soggetto ad attacchi di tipo DOS. Ecco perché è fondamentale compiere ottimizzazioni
per scartare le richieste il prima possibile.

\subsection{Implementazione della matrice}
La matrice di controllo degli accessi può essere implementata principalmente in due modi:
\begin{itemize}
	\item Per \textbf{righe}: soluzione a \emph{capability} o \emph{ticket}.
	\item Per \textbf{colonne}: soluzione a \emph{lista di controllo} degli accessi (ACL).
\end{itemize}
La soluzione a \emph{capability} memorizza le informazioni relative ad un oggetto e alle relative operazioni che si
possono effettuare su esso ad un certo indirizzo (logico o fisico).

Questo indirizzo viene memorizzato nell'ambiente del soggetto. Quando un soggetto vuole eseguire un'operazione deve
indicare l'operazione che vuole eseguire e la \emph{capability} di cui dispone.