\section{Reti combinatorie}
Nel corso non andremo a trattare l'ultimo livello di astrazione, ossia quello più basso, ma andremo
a trattare lo strato soprastante, che tramite delle \textbf{porte logiche} e delle operazioni
aritmetiche binarie riesce a rappresentare quello che succede. Le tre operazioni implmentate dalle
porte logiche sono
\begin{itemize}
	\item \verb|AND(x,y)|: 1 se $x = y = 1$, 0 altrimenti.
	\item \verb|OR(x,y)|: 0 se $x = y = 0$, 1 altrimenti.
	\item \verb|NOT(x)|: 1 se $x=0$, 0 se $x=1$.
\end{itemize}
Altro strumento utile per capire meglio come funzionano tali porte e per vedere come funzionano
altre porte che risultano essere una combinazione di esse, sono le \textbf{tabelle di verità}.
Nelle tabelle di verità immettiamo tutti i possibili valori di input e calcoliamo i relativi output.
Per esempio, la tabella di verità di una porta logica \verb|AND| è la seguente
\begin{center}
	\begin{tabular}{c c | c}
		x & y & z \\ \hline
		0 & 0 & 0 \\
		0 & 1 & 0 \\
		1 & 0 & 0 \\
		1 & 1 & 1
	\end{tabular}
\end{center}
Per una questione legata alla circuiteria sottostante e alla leggi fisiche che regolano il
funzionamento dei transistor, il numero di ingressi delle porte è, in genere, al più 8 poiché
averne di più introduce troppo ritardo nell'elaborazione dei segnali.

Quelle che useremo d'ora in poi saranno \textbf{reti combinatorie}, ossia delle funzioni che hanno
un certo numero di ingressi e un certo numero di uscite, formate da una composizione di porte
\verb|AND|, \verb|OR| e \verb|NOT|.

Supponiamo ad esempio di voler implementare una rete combinatoria in grado di calcolare il numero
di bit a 1 su 2 ingressi, ciascuno da 1 bit. In questo caso i possibili valori di output sono 3 (0,
1 e 2) e abbiamo quindi bisogno di un numero di uscite pari a $\lceil \log_2 (3) \rceil = 2$. La
tabella di verità del nostro circuito sarà la seguente
\begin{center}
	\begin{tabular}{c c | c c}
		$x_0$ & $x_1$ & $z_0$ & $z_1$ \\ \hline
		0     & 0     & 0     & 0     \\
		0     & 1     & 0     & 1     \\
		1     & 0     & 0     & 1     \\
		1     & 1     & 1     & 0
	\end{tabular}
\end{center}
Per trovare il circuito desiderato c'è una procedura standard, la quale utilizza il fatto che un
\verb|AND| logico corrisponde al prodotto tra due numeri mentre l'\verb|OR| logico corrisponde alla
somma:
\begin{enumerate}
	\item Per ogni riga in cui una delle colonne d'uscita presenta almeno un 1 mettiamo in
	      \verb|AND| gli ingressi, negandoli se uguali a 0.
	\item Per ogni colonna si mettono in \verb|OR| tutti i risultati ottenuti al passo precedente.
\end{enumerate}
Nel nostro caso la colonna $z_0$ ha un 1 sull'ultima riga e i relativi valori di $x_0$ e $x_1$ sono
entrambi 1 quindi possiamo dire che
\[ z_0 = x_0 \cdot x_1 \]
ossia
\begin{center}
	\verb|z0 = AND(x0, x1)|
\end{center}
Per quanto riguarda invece la colonna $z_1$ abbiamo due 1 e in corrispondenza della seconda e terza
riga. Ma in entrambi i casi uno dei due valori in ingresso è 0 e l'altro è 1 e dunque il risultato
finale è
\[ z_1 = \bar{x_0} \cdot x_1 + x_0 \cdot \bar{x_1} \]
ossia
\begin{center}
	\verb|z1 = OR(AND(NOT(x0), x1), AND(x0, NOT(x1)))|
\end{center}
Il circuito logico che ne deriva è il seguente
\begin{center}
	\begin{circuitikz}
		% gate
		\node[and port] (and1) at (3.5, -1) {};
		\node[and port] (and2) at (3.5, -2.5) {};
		\node[and port] (and3) at (3.5, -4) {};
		\node[or port] (or) at (5.5, -3.25) {};

		% connessioni
		\draw (0, 0) node[label=above:$x_0$] {} to[short, -*] (0, 52 |- and1.in 1) -- (and1.in 1);
		\draw (0, 52 |- and1.in 1) to[short, -*] (0, 52 |- and2.in 1) to[short, -o] (and2.in 1);
		\draw (0, 52 |- and2.in 1) to[short, -*] (0, 52 |- and3.in 1) -- (and3.in 1);

		\draw (1, 0) node[label=above:$x_1$] {} to[short, -*] (1, 52 |- and1.in 2) -- (and1.in 2);
		\draw (1, 52 |- and1.in 2) to[short, -*] (1, 52 |- and2.in 2) -- (and2.in 2);
		\draw (1, 52 |- and2.in 2) to[short, -*] (1, 52 |- and3.in 2) to[short, -o] (and3.in 2);

		\draw (and2.out) |- (or.in 1);
		\draw (and3.out) |- (or.in 2);

		\draw (and1.out) -- (6.5, 52 |- and1.out) node[label=above:$z_0$] {};
		\draw (or.out) -- (6.5, 52 |- or.out) node[label=above:$z_1$] {};
	\end{circuitikz}
\end{center}
sul quale è possibile provare ad inserire vari input di $x_0$ e $x_1$ per verificarne la
correttezza.

Supponiamo ora di dover scegliere uno tra due ingressi possibili a seconda di un ingresso di
controllo regolato da un \textbf{multiplexer} che ha una forma di questo tipo
\begin{center}
	\begin{tikzpicture}
		\draw[thick] (-1.25, 1) -- (1.25, 1) -- (0.75, 0) -- (-0.75, 0) -- cycle;
		\node (mux) at (0, 0.5) {MUX};
		\draw (-0.5, 1.5) node[label=left:$x_0$] {} to[short, o-] (-0.5, 1);
		\draw (0.5, 1.5) node[label=right:$x_1$] {} to[short, o-] (0.5, 1);
		\draw (-1.75, 0.5) node[label=left:$c$] {} to[short, o-] (-1, 0.5);
		\draw (0, 0) -- (0, -0.75) node[label=right:$z$] {};
	\end{tikzpicture}
\end{center}
Di fatto dobbiamo implementare un circuito che da come risultato il valore di $x_0$ quando $c=0$ e
da come risultato il valore di $x_1$ quando $c=1$.

In questo caso abbiamo tre ingressi e un'uscita, dovremmo quindi scrivere una tabella di verità con
8 righe, ma dato che uno dei valori viene scartato a seconda del valore di $c$ il risultato è una
tabella più compatta.

Avere una tabella più compatta significa anche avere un circuito più compatto e con meno componenti.
Questo si traduce in un minor numero di nodi di calcolo e quindi una computazione più veloce, ma
anche in un minor consumo di energia e minor bisogno di spazio sul processore.
\begin{center}
	\begin{tabular}{c c c | c}
		$x_0$ & $x_1$ & $c$ & $z$ \\ \hline
		0     & -     & 0   & 0   \\
		1     & -     & 0   & 1   \\
		-     & 0     & 1   & 0   \\
		-     & 1     & 1   & 1
	\end{tabular}
\end{center}
Svolgiamo lo stesso procedimento di prima e ricaviamo un circuito di questo tipo
\begin{center}
	\begin{circuitikz}
		\node[and port] (and1) at (3.5, 0.75) {};
		\node[and port] (and2) at (3.5, -0.75) {};
		\node[or port] (or) at (5.5, 0) {};

		% connessioni
		\draw (0, 1.5) node[label=above:$x_0$] {} to[short, -*] (0, 52 |- and1.in 1) -- (and1.in 1);

		\draw (0.5, 1.5) node[label=above:$x_1$] {} to[short, -*] (0.5, 52 |- and2.in 1) -- (and2.in 1);

		\draw (1, 1.5) node[label=above:$c$] {} to[short, -*] (1, 52 |- and1.in 2) to[short, -o] (and1.in 2);
		\draw (1, 52 |- and1.in 2) to[short, -*] (1, 52 |- and2.in 2) -- (and2.in 2);

		\draw (and1.out) |- (or.in 1);
		\draw (and2.out) |- (or.in 2);

		\draw (or.out) -- (6.5, 52 |- or.out) node[label=above:$z$] {};
	\end{circuitikz}
\end{center}
che calcola esattamente
\[ z = x_0 \cdot \bar{c} + x_1 \cdot c \]
ossia il valore del canale scelto dal multiplexer.

\subsection{Algebra di Boole}
L'\textbf{algebra di Boole}, tramite gli \textbf{assiomi} che determinano il comportamento
dell'alfabeto $\{0, 1\}$ in relazione a delle operazioni di base che possiamo fare con i suoi
elementi, ci permette di semplificare o più in generale di manipolare le espressioni dell'algebra
booleana per andare quindi a modellare anche i nostri circuiti. Di seguito andremo ad elencarli
\begin{gather*}
	a = 0 \implies a \neq 1 \quad \land \quad a = 1 \implies a \neq 0 \\
	a = 0 \implies \bar{a} = 1 \quad \land \quad a = 1 \implies \bar{a} = 0 \\
	0 \cdot 1 = 0 \quad \land \quad 1 \cdot 0 = 0 \\
	0 \cdot 0 = 0 \quad \land \quad 1 \cdot 1 = 1 \\
	0 + 1 = 1 \quad \land \quad 1 + 0 = 1 \\
	0 + 0 = 0 \quad \land \quad 1 + 1 = 1
\end{gather*}
Da questi deduciamo anche che
\begin{gather*}
	A \cdot 1 = A \quad \land \quad A + 0 = A \\
	A \cdot 0 = 0 \quad \land \quad A + 1 = 1 \\
	A \cdot A = A \quad \land \quad A + A = A \\
	A \cdot \bar{A} = 0 \quad \land \quad A + \bar{A} = 1 \\
	\bar{\bar{A}} = A
\end{gather*}
Le operazioni di \verb|AND|, \verb|OR| e \verb|NOT| dell'algebra booleana godono di alcune
proprietà molto utili per la manipolazione delle espressioni boooleane:
\begin{itemize}
	\item \textbf{Commutatività} per l'\verb|AND|: $A \cdot B = B \cdot A$
	\item \textbf{Commutatività} per l'\verb|OR|: $A + B = B + A$
	\item \textbf{Distributività}: $A \cdot (B + C) = A \cdot B + A \cdot C$ e la formula duale
	      $A + (B \cdot C) = (A \cdot B) + (A \cdot C)$
	\item \textbf{De Morgan}: $\overline{A \cdot B} = \bar{A} + \bar{B}$ e la formula duale
	      $\overline{A + B} = \bar{A} \cdot \bar{B}$
\end{itemize}
Con queste proprietà è possibile semplificare alcune delle formule generate da alcune tabelle di
verità come abbiamo fatto nel caso del multiplexer. Supponiamo che per un qualche motivo otteniamo
una funzione di $a$, $b$ e $c$ tale che
\[ f(a,b,c) = \bar{a} \bar{b} \bar{c} + a \bar{b} \bar{c} + a \bar{b} c \]
Se volessimo implementare questa formula tramite un circuito avremmo bisogno di tre porte
\verb|AND3| e di 1 porta \verb|OR3|. Usando le proprietà possiamo ottenere
\[
	\bar{a} \bar{b} \bar{c} + a \bar{b} \bar{c} + a \bar{b} c
	= \bar{b} \bar{c} (\bar{a} + a) + a \bar{b} c
	= \bar{b} \bar{c} + a \bar{b} c
\]
Passando così ad una formula che ci permette di implementare un circuito tramite due porte
\verb|AND3| e una porta \verb|OR3|. Proviamo un altro modo di procedere
\begin{align*}
	\bar{a} \bar{b} \bar{c} + a \bar{b} \bar{c} + a \bar{b} c
	 & = \bar{a} \bar{b} \bar{c} + a \bar{b} \bar{c} + a \bar{b} \bar{c} + a \bar{b} c         \\
	 & = \bar{b} \bar{c} (\bar{a} + a) + a \bar{b} (c + \bar{c}) = \bar{b} \bar{c} + a \bar{b}
\end{align*}
ottenendo così la possibilità di implementare un circuito tramite due porte \verb|AND2| e una porta
\verb|OR2|. Come possiamo vedere, a seconda di come usiamo queste proprietà, è possibile diminuire
notevolmente la dimensione dei circuiti e quindi la complessità di ciò che stiamo calcolando.
\begin{center}
	\begin{circuitikz}
		% gates
		\node[and port] (and1) at (3.5, 1) {};
		\node[and port] (and2) at (3.5, -1) {};
		\node[or port] (or) at (5.5, 0) {};

		\draw (0, 2) node[label=above:$a$] {} to[short, -*] (0, 52 |- and2.in 1) -- (and2.in 1);
		\draw (0.5, 2) node[label=above:$b$] {} to[short, -*] (0.5, 52 |- and1.in 1) to[short, -o] (and1.in 1);
		\draw (0.5, 52 |- and1.in 1) to[short, -*] (0.5, 52 |- and2.in 2) to[short, -o] (and2.in 2);
		\draw (1, 2) node[label=above:$c$] {} to[short, -*] (1, 52 |- and1.in 2) to[short, -o] (and1.in 2);

		\draw (and1.out) |- (or.in 1);
		\draw (and2.out) |- (or.in 2);
	\end{circuitikz}
\end{center}
A questo punto sarebbe possibile semplificare ulteriormente la formula raccogliendo $\bar{b}$ e
implementando il circuito descritto da
\[ \bar{b} \cdot (\bar{c} + a) \]
ma questo introduce un problema in quanto il circuito generato è asimmetrico, ossia i segnali in
ingresso non attraversano tutti lo stesso numero di porte come possiamo vedere in figura
\begin{center}
	\begin{circuitikz}
		\node[or port] (or) at (3.5, 1) {};
		\node[and port] (and) at (5.5, 0) {};

		\draw (0, 2) node[label=above:$a$] {} to[short, -*] (0, 52 |- or.in 1) -- (or.in 1);
		\draw (0.5, 2) node[label=above:$b$] {} to[short, -*] (0.5, 52 |- and.in 2) to[short, -o] (and.in 2);
		\draw (1, 2) node[label=above:$c$] {} to[short, -*] (1, 52 |- or.in 2) to[short, -o] (or.in 2);

		\draw (or.out) |- (and.in 1);
	\end{circuitikz}
\end{center}
Questo si traduce in un intervallo di tempo in cui la porta \verb|AND| riceve, da una parte il
vecchio segnale trasmesso dalla porta \verb|OR| prodotto al calcolo precedente, dall'altra l'ultimo
segnale prodotto dall'ingresso $b$.

Fino a che la porta \verb|OR| non finisce di elaborare i segnali in arrivo da $a$ e $c$ la porta
\verb|AND| potrebbe produrre risultati errati, dovuti a quello che viene chiamato \textbf{glitch}.

\subsection{Mappe di Karnaugh}
Come abbiamo appena visto, non sempre ridurre la complessità della nostra formula in modo
\emph{monotòno} ci porta alla migliore ottimizzazione. A volte conviene aumentare la complessità
per poi giungere ad un modello migliore.

Le \textbf{mappe di Karnaugh} forniscono un metodo grafico per riuscire a semplificare le formule
booleane senza però garantire la miglior minimizzazione di quest'ultime. Nell'esempio di prima
abbiamo una funzione booleana con la seguente tabella di verità
\begin{center}
	\begin{tabular}{c c c | c}
		$a$ & $b$ & $c$ & $f(a,b,c)$ \\ \hline
		0   & 0   & 0   & 1          \\
		0   & 0   & 1   & 0          \\
		0   & 1   & 0   & 0          \\
		0   & 1   & 1   & 0          \\
		1   & 0   & 0   & 1          \\
		1   & 0   & 1   & 1          \\
		1   & 1   & 0   & 0          \\
		1   & 1   & 1   & 0
	\end{tabular}
\end{center}
Da questa tabella possiamo ricavare una mappa di Karnaugh prendendo tutti i possibili valori di $a$
e mettendoli nella prima colonna e poi prendendo tutti i possibili valori della coppia $bc$ e
mettendoli sulla prima riga, disponendoli in modo che ogni valore differisca dal precedente al più
di un bit.

Il nostro obbiettivo è quello di individuare i quadrati o rettangoli contenenti un numero di 1 pari
ad una potenza di 2 e raggrupparli. Per tale raggruppamento è possibile
\begin{itemize}
	\item Uscire dalla tabella e rientrare dall'altra parte se ho degli 1 agli estremi.
	\item Includere degli 1 già raccolti in un precedente raggruppamento.
\end{itemize}
Nel nostro caso abbiamo due rettangoli da due 1: il primo verticale che prende la prima colonna per
intero e il secondo orizzontale che prende la prima metà della seconda riga.
\begin{center}
\begin{karnaugh-map}[4][2][1][$c$][$b$][$a$]
\maxterms{1, 2, 3, 6, 7}
\minterms{0, 4, 5}
\implicant{0}{4}
\implicant{4}{5}
\end{karnaugh-map}
\end{center}
A questo punto siamo
in grado di semplificare la formula di partenza
\begin{enumerate}
	\item Mettendo in \verb|AND| le variabili facenti parte dello stesso raggruppamento che
	      rimangono costanti e negando quelle con valore 0.
	\item Sommando tra di loro i raggruppamenti.
\end{enumerate}
Otteniamo così la formula ottenuta in precedenza con le proprietà dell'algebra booleana
\[ \bar{b} \bar{c} + a \bar{b} \]
in modo meccanico. Il primo termine della somma è ottenuto prendendo in considerazione il
raggruppamento verticale di 1 e considerando che $b$ e $c$ non variano ed essendo a 0 vengono
negati. Il secondo termini si ottiene similmente notando che $a$ e $b$ sono la parte costante del
raggruppamento ed inoltre $b$ è a 0 e dunque deve essere negato.

Prendiamo ora come esempio un \textbf{addizionatore} di 2 bit con riporto, il cui funzionament
dipende da tre parametri di ingresso: $x_1$ e $x_2$ i bit che vogliamo sommare e $r_0$ il possibile
riporto da aggiungere. Abbiamo inoltre due uscite: il risultato $s$ della somma e il possibile
riporto $r_1$ generato da essa.
\begin{center}
	\begin{tikzpicture}
		\draw[thick] (0, 0) rectangle (2, 1.5);
		\node (add) at (1, 0.75) {ADD};

		\draw (0.5, 2) node[label=above:$x_1$] {} to[short, o-] (0.5, 1.5);
		\draw (1.5, 2) node[label=above:$x_2$] {} to[short, o-] (1.5, 1.5);
		\draw (2.5, 0.75) node[label=right:$r_0$] {} to[short, o-] (2, 0.75);
		\draw (0, 0.75) -- (-0.5, 0.75) -- (-0.5, -0.75) node[label=below:$r_1$] {};
		\draw (1, 0) -- (1, -0.75) node[label=below:$s$] {};
	\end{tikzpicture}
\end{center}
Le mappe di Karnaugh per $s$ ed $r_1$ risultano le seguenti
\begin{center}
\begin{figure}[h!] \centering
\begin{subfigure}[b]{0.4\textwidth}
\begin{karnaugh-map}[4][2][1][$c$][$b$][$a$]
\minterms{1,2,4,7}
\maxterms{0,3,5,6}
\implicant{1}{1}
\implicant{2}{2}
\implicant{4}{4}
\implicant{7}{7}
\end{karnaugh-map}
\end{subfigure}
\begin{subfigure}[b]{0.4\textwidth}
\begin{karnaugh-map}[4][2][1][$c$][$b$][$a$]
\minterms{3,5,7,6}
\maxterms{0,1,2,4}
\implicant{3}{7}
\implicant{7}{6}
\implicant{5}{6}
\end{karnaugh-map}
\end{subfigure}
\end{figure}
\end{center}
Da tali mappe di Karnaugh ricaviamo le seguenti formule per $s$ ed $r_1$
\begin{align*}
	s   & = r_0 \bar{x_1} \bar{x_2} + \bar{r_0} \bar{x_1} x_2 + r_0 x_1 x_2 + \bar{r_0} x_1 \bar{x_2} \\
	r_1 & = x_1 x_2 + r_0 x_2 + r_0 x_1
\end{align*}
Di seguito raffiguriamo il circuito ricavato dalla formula per $r_1$.
\begin{center}
	\begin{circuitikz}
		\node[and port] (and1) at (3.5, 1.5) {};
		\node[and port] (and2) at (3.5, 0) {};
		\node[and port] (and3) at (3.5, -1.5) {};
		\node[or port, number inputs=3] (or) at (5.5, 0) {};

		\draw (0, 2) node[label=above:$x_1$] {} to[short, -*] (0, 52 |- and1.in 1) -- (and1.in 1);
		\draw (0, 52 |- and1.in 1) to[short, -*] (0, 52 |- and3.in 2) -- (and3.in 2);

		\draw (0.5, 2) node[label=above:$x_2$] {} to[short, -*] (0.5, 52 |- and1.in 2) -- (and1.in 2);
		\draw (0.5, 52 |- and1.in 2) to[short, -*] (0.5, 52 |- and2.in 2) -- (and2.in 2);

		\draw (1, 2) node[label=above:$r_0$] {} to[short, -*] (1, 52 |- and2.in 1) -- (and2.in 1);
		\draw (1, 52 |- and2.in 1) to[short, -*] (1, 52 |- and3.in 1) -- (and3.in 1);

		\draw (and1.out) -- (or.in 1);
		\draw (and2.out) -- (or.in 2);
		\draw (and3.out) -- (or.in 3);
		\draw (or.out) --++ (0.5, 0) node[label=right:$r_1$] {};
	\end{circuitikz}
\end{center}
Per riassumere possiamo usare sia le regole e gli assiomi dell'algebra booleana per semplificare le
formule ma questo potrebbe portarci sia alla minima forma possibile sia ad un'espressione più
complessa. Con le mappe di Karnaugh non abbiamo la certezza di ottenere la miglior minimizzazione
ma ci offre un modo meccanico per ridurre la complessità.

Vogliamo ora implementare un \textbf{moltiplicatore} che moltiplica due sequenze da 2 bit dando
come risultato una sequenza da 4 bit. Per capire come calcolare tale sequenza possiamo procedere
tramite una tabella di verità che però, avendo 4 bit di ingresso risulta avere 16 righe. Cerchiamo
quindi di rappresentare solo le righe significative.
\begin{center}
	\begin{tabular}{c c c c | c c c c}
		$x_1$ & $x_2$ & $y_1$ & $y_2$ & $z_1$ & $z_2$ & $z_3$ & $z_4$ \\ \hline
		0     & 0     & -     & -     & 0     & 0     & 0     & 0     \\
		-     & -     & 0     & 0     & 0     & 0     & 0     & 0     \\ \hline
		0     & 1     & 0     & 1     & 0     & 0     & 0     & 1     \\
		      &       & 1     & 0     & 0     & 0     & 1     & 0     \\
		      &       & 1     & 1     & 0     & 0     & 1     & 1     \\ \hline
		1     & 0     & 0     & 1     & 0     & 0     & 1     & 0     \\
		      &       & 1     & 0     & 0     & 1     & 0     & 0     \\
		      &       & 1     & 1     & 0     & 1     & 1     & 0     \\ \hline
		1     & 1     & 0     & 1     & 0     & 0     & 1     & 1     \\
		      &       & 1     & 0     & 0     & 1     & 1     & 0     \\
		      &       & 1     & 1     & 1     & 0     & 0     & 1     \\
	\end{tabular}
\end{center}
A questo punto possiamo disegnare una mappa di Karnaugh per ogni uscita $z_i$ che abbiamo,
limitiamoci per il momento a disegnare solo quelle di $z_1$ e $z_3$.
% \begin{center}
\begin{figure}[!h]\centering
\resizebox{.6\textwidth}{!}{
	\begin{subfigure}[b]{0.4\textwidth}
	\begin{karnaugh-map}[4][4][1][$y_2$][$y_1$][$x_2$][$x_1$]
	\minterms{15}
	\maxterms{0,1, 3, 2, 4, 5, 7, 6, 12, 13, 14, 8, 9, 11, 10}
	\implicant{15}{15}
	\end{karnaugh-map}
	\end{subfigure}
	\begin{subfigure}[b]{0.4\textwidth}
	\begin{karnaugh-map}[4][4][1][$y_2$][$y_1$][$x_2$][$x_1$]
	\minterms{6, 7, 15, 13, 9, 10}
	\maxterms{0, 1, 3, 2, 4, 5, 12, 14, 8, 11}
	\implicant{7}{15}
	\implicant{7}{6}
	\implicant{13}{9}
	\implicant{10}{10}
	\end{karnaugh-map}
	\end{subfigure}
}
\end{figure}
% \end{center}

Come possiamo vedere anche dalle formule che seguono, per il calcolo di $z_1$ è sufficiente una
porta \verb|AND| mentre per il calcolo di $z_3$ sono necessarie 4 porte \verb|AND| e 1 porta
\verb|OR|. C'è quindi un ritardo tra il calcolo di $z_1$ e $z_3$ e il ritardo complessivo è dovuto
al passaggio del calcolo da 2 livelli di porte logiche.
\begin{align*}
	z_1 & = x_1 x_2 y_1 y_2                                                                   \\
	z_3 & = x_1 \bar{y_1} y_2 + x_2 y_1 y_2 + \bar{x_1} x_2 y_1 + x_1 \bar{x_2} y_1 \bar{y_2}
\end{align*}
In alternativa, considerando che una moltiplicazione tra due sequenze di 2 bit si svolge in questo
modo
\begin{center}
	\begin{tabular}{c c c c}
		  & 1 & 1 & $\times$ \\
		  & 1 & 0 & =        \\ \hline
		  & 0 & 0 & +        \\
		1 & 1 & - & =        \\ \hline
		1 & 1 & 0
	\end{tabular}
\end{center}
possiamo notare che se il bit al moltiplicatore è 0 allora avremo tutti 0 mentre se abbiamo 1 il
risultato sarà esattamente il moltiplicando. Possiamo quindi calcolarci separatamente
$x_1 x_2 \cdot y_1$ e $x_1 x_2 \cdot y_2$ tramite due multiplexer di questo tipo
\begin{center}
	\begin{tikzpicture}
		\draw[thick] (-1.25, 1) -- (1.25, 1) -- (0.75, 0) -- (-0.75, 0) -- cycle;
		\node (mux) at (0, 0.5) {MUX};
		\draw (-0.5, 1.5) node[label=left:$x_1 x_2$] {} to[short, o-] (-0.5, 1);
		\draw (0.5, 1.5) node[label=right:$00$] {} to[short, o-] (0.5, 1);
		\draw (-1.75, 0.5) node[label=left:$y_i$] {} to[short, o-] (-1, 0.5);
		\draw (0, 0) -- (0, -0.75);
	\end{tikzpicture}
\end{center}
Dove $x_1 x_2$ è un ingresso da 2 bit e dove l'altro ingresso è la costante 00. Questo multiplexer
effettua esattamente la scelta di cui abbiamo parlato prima: se $y_i = 0$ dà come risultato 00, se
invece $y_i = 1$ dà come risultato $x_1 x_2$.

Per implementare un moltiplicare $2 \times 2$ dobbiamo sostanzialmente affiancare due di questi
multiplexer, uno per $y_1$ e uno per $y_2$, aggiungere degli zeri dove necessario e poi effettuare
una somma con un bit di riporto $r$ che viene messo in cima alla sequenza generata. Il circuito che
ne risulta è un qualcosa di questo tipo
\begin{center}
	\begin{tikzpicture}
		\draw[thick] (-4.25, 1) -- (-1.75, 1) -- (-2.25, 0) -- (-3.75, 0) -- cycle;
		\node (mux) at (-3, 0.5) {MUX};
		\draw (-3.5, 1.5) node[label=left:$x_1 x_2$] {} to[short, o-] (-3.5, 1);
		\draw (-2.5, 1.5) node[label=right:$00$] {} to[short, o-] (-2.5, 1);
		\draw (-4.75, 0.5) node[label=left:$y_1$] {} to[short, o-] (-4, 0.5);
		\draw (-3, 0) -- (-3, -1) node[label=above left:$z_1 z_2$] {};

		\draw[thick] (4.25, 1) -- (1.75, 1) -- (2.25, 0) -- (3.75, 0) -- cycle;
		\node (mux) at (3, 0.5) {MUX};
		\draw (2.5, 1.5) node[label=left:$x_1 x_2$] {} to[short, o-] (2.5, 1);
		\draw (3.5, 1.5) node[label=right:$00$] {} to[short, o-] (3.5, 1);
		\draw (4.75, 0.5) node[label=right:$y_2$] {} to[short, o-] (4, 0.5);
		\draw (3, 0) -- (3, -1) node[label=above right:$z_3 z_4$] {};

		\draw (-1.5, -0.5) node[label=right:$0$] {} to[short, o-] (-1.5, -1) to[short, -*] (-2.25, -1);
		\draw (-3, -1) -- (-2.25, -1) -- (-2.25, -1.75) -- (-0.5, -1.75) -- (-0.5, -2.5);

		\draw (1.5, -0.5) node[label=left:$0$] {} to[short, o-] (1.5, -1) to[short, -*] (2.25, -1);
		\draw (3, -1) -- (2.25, -1) -- (2.25, -1.75) -- (0.5, -1.75) -- (0.5, -2.5);

		\draw[thick] (-1, -2.5) rectangle (1, -3.75);
		\node (add) at (0, -3.125) {ADD};
		\draw (0, -3.75) -- (0, -4.25);
		\draw (-1, -3.125) -- (-1.5, -3.125) -- node[label=left:$r$] {} (-1.5, -4.25);
	\end{tikzpicture}
\end{center}
In questo modo, dato che, come abbiamo visto in precendenza, sia il multiplexer che l'addizionatore
sono implementati tramite un circuito a due livelli di porte logiche abbiamo in totale un circuito
costituito da quattro livelli di porte logiche.

Questo si traduce in un maggior numero di componenti e in un maggior tempo di elaborazione ma in
compenso facciamo uso di due componenti standard che abbiamo già implementato e non dobbiamo
ricorrere alla costruzione di tabelle di verità, mappe di Karnaugh ecc.

Altro circuito considerato standard è il \textbf{demultiplexer} il quale ha $n$ bit in ingresso e
$2^n$ bit in uscita, e mette a 1 solo l'$n$-esimo bit lasciando tutti gli altri a 0. Se ad esempio
avessimo in ingresso 2 bit, avremo di conseguenza un circuito di questo tipo
\begin{center}
	\begin{tikzpicture}
		\draw[thick] (-0.8, 1) -- (0.8, 1) -- (1.5, 0) -- (-1.5, 0) -- cycle;
		\node (mux) at (0, 0.5) {DEMUX};

		\draw (-0.5, 1.5) node[label=above:$x_1$] {} to[short, o-] (-0.5, 1);
		\draw (0.5, 1.5) node[label=above:$x_2$] {} to[short, o-] (0.5, 1);

		\draw (-1.25, 0) -- (-1.25, -0.5) node[label=below:$z_1$] {};
		\draw (-0.5, 0) -- (-0.5, -0.5) node[label=below:$z_2$] {};
		\draw (0.5, 0) -- (0.5, -0.5) node[label=below:$z_3$] {};
		\draw (1.25, 0) -- (1.25, -0.5) node[label=below:$z_4$] {};
	\end{tikzpicture}
\end{center}
e la tabella di verità corrispondente sarebbe la solita
\begin{center}
	\begin{tabular}{c c | c c c c}
		$x_1$ & $x_2$ & $z_1$ & $z_2$ & $z_3$ & $z_4$ \\ \hline
		0     & 0     & 1     & 0     & 0     & 0     \\
		0     & 1     & 0     & 1     & 0     & 0     \\
		1     & 0     & 0     & 0     & 1     & 0     \\
		1     & 1     & 0     & 0     & 0     & 1
	\end{tabular}
\end{center}
Le formule risultanti da questa tabella sono
\begin{align*}
	z_1 & = \bar{x_1} \bar{x_2} \\
	z_2 & = \bar{x_1} x_2       \\
	z_3 & = x_1 \bar{x_2}       \\
	z_4 & = x_1 x_2
\end{align*}
Il circuito risultante sarebbe molto semplicemente
\begin{center}
	\begin{circuitikz}
		\node[and port] (and1) at (0, 2.25) {};
		\node[and port] (and2) at (0, 0.75) {};
		\node[and port] (and3) at (0, -0.75) {};
		\node[and port] (and4) at (0, -2.25) {};

		\draw (-4, 0.75) node[label=left:$x_1$] {} to[short, o-*] (-2.5, 0.75) --
		(-2.5, 52 |- and1.in 1) to[short, -o] (and1.in 1)
		(-2.5, 0.5) -- (-2.5, 52 |- and2.in 1) to[short, *-o] (and2.in 1)
		(-2.5, 0.5) to[short, -*] (-2.5, 52 |- and3.in 1) -- (and3.in 1)
		(-2.5, 0.5) -- (-2.5, 52 |- and4.in 1) -- (and4.in 1);

		\draw (-4, -0.75) node[label=left:$x_2$] {} to[short, o-*] (-3.5, -0.75) --
		(-3.5, 52 |- and1.in 2) to[short, -o] (and1.in 2)
		(-3.5, 0.5) -- (-3.5, 52 |- and2.in 2) to[short, *-] (and2.in 2)
		(-3.5, 0.5) to[short, -*] (-3.5, 52 |- and3.in 2) to[short, -o] (and3.in 2)
		(-3.5, 0.5) -- (-3.5, 52 |- and4.in 2) -- (and4.in 2);

		\draw (and1.out) --++ (0.5, 0) node[label=right:$z_1$] {};
		\draw (and2.out) --++ (0.5, 0) node[label=right:$z_2$] {};
		\draw (and3.out) --++ (0.5, 0) node[label=right:$z_3$] {};
		\draw (and4.out) --++ (0.5, 0) node[label=right:$z_4$] {};
	\end{circuitikz}
\end{center}
