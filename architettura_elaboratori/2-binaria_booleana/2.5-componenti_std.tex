\section{Componenti standard}
Andiamo ora a definire alcune delle componenti, con relativa implementazione, che andremo ad
utilizzare molto spesso d'ora in poi e che considereremo \textbf{componenti standard}.

Possiamo dividere tali componenti in \textbf{componenti di reti combinatorie} e
\textbf{componenti di reti sequenziali}.

\subsection{Componenti di reti combinatorie}
Le componenti che andremo a vedere sono le componenti principali per lo svolgimento dei calcoli
aritmetici e per la valutazione di espressioni booleane.

\subsubsection{Addizionatore}
La prima componente che andiamo a vedere è l'addizionatore di due sequenza da $n$ bit ciascuna che
restituisce una sequenza da $n$ bit e un riporto. Il componente lo indicheremo d'ora in poi in
questo modo
\begin{center}
	\begin{tikzpicture}[scale=0.75]
		\draw[thick] (-1, 0) -- (-1.5, 1.5) -- (-0.2, 1.5) -- (0, 1.25) -- (0.2, 1.5) -- (1.5, 1.5) -- (1, 0) -- cycle;
		\node (add) at (0, 0.75) {+};

		\draw (-1, 2) node[label=above:$x$] {} to[short, o-] (-1, 1.5);
		\draw (1, 2) node[label=above:$y$] {} to[short, o-] (1, 1.5);
		\draw (2, 0.75) node[label=right:$r_\text{in}$] {} to[short, o-] (1.25, 0.75);
		\draw[->, >=Stealth] (-1.25, 0.75) -- (-2, 0.75) -- (-2, -0.75) node[label=below:$r_\text{out}$] {};
		\draw[->, >=Stealth] (0, 0) -- (0, -0.75) node[label=below:$s$] {};
	\end{tikzpicture}
\end{center}
Come abbiamo visto in Verilog, è possibile implementare un addizionatore di due sequenze da 2 bit
ciascuna, concatenando due addizionatori da 1 bit. Questo però implica che ogni addizionatore
inizia il calcolo quando quello che ha calcolato la cifra meno significativa ha finito il suo
calcolo e generato un prodotto.

Dato che ogni addizionatore da 1 bit deve attraversare due livelli di porte logiche, se
concantenassimo $n$ addizionatori da 1 bit dovrebbe attendere $2 n \Delta t$ per effettuare una
somma a $n$ bit.

Si prova quindi a calcolare il riporto in anticipo con una tecnica chiamata \textbf{Carry look ahead}.
Questa tecnica tiene di conto che una somma tra due bit $x$ e $y$
\begin{itemize}
	\item \textbf{Genera} un riporto se e solo $x = y = 1$.
	\item \textbf{Propoaga} un riporto se e solo se $x = 1$ o $y = 1$.
\end{itemize}
Vale quindi che, data una certa colonna della somma, abbiamo un riporto se generiamo o propaghiamo
un riporto. Da questa considerazione ricaviamo la formula ricorsiva
\[ C_{i+1} = G_i + P_i \cdot C_i \]
dove $G_i = x_i \cdot y_i$ e $P_i = x_i + y_i$, che ci permette di calcolare il riporto $C$
generato da una somma di due sequenze di $i+1$ bit.

Così facendo abbiamo un circuito con $k$ porte in cascata per ogni sottosequenza di bit e a seconda
di quanto è lunga la sequenza principale e di quante sottosequenze abbiamo generato si dovrebbe
ottenere una leggera ottimizzazione in termini di livelli di porte da attraversare.

In questo modo il calcolo del riporto è indipendente dal calcolo della somma e dunque il calcolo
della somma successiva può iniziare in anticipo.

\subsubsection{Comparatore}
Componente utile per capire se due sequenza di bit $x$ e $y$ sono uguali oppure no. Per la
comparazione di due bit singoli abbiamo già la porta \verb|XNOR| che ritorna 1 se e solo se i due
bit hanno lo stesso valore. Un circuito in grado di comparare due sequenze di $n$ bit sarebbe
\begin{center}
	\begin{circuitikz}
		\node[xnor port] (xnor1) at (-0.5, 1.25) {};
		\node[xnor port] (xnor2) at (-0.5, -1.25) {};
		\node[and port] (and) at (2, 0) {};

		\draw (-3, 52 |- xnor1.in 1) node[label=left:$x_0$] {} -- (xnor1.in 1);
		\draw (-3, 52 |- xnor1.in 2) node[label=left:$y_0$] {} -- (xnor1.in 2);

		\node at (-1.5, 0) {$\vdots$};
		\node at (-3.5, 0) {$\vdots$};

		\draw (-3, 52 |- xnor2.in 1) node[label=left:$x_{n-1}$] {} -- (xnor2.in 1);
		\draw (-3, 52 |- xnor2.in 2) node[label=left:$y_{n-1}$] {} -- (xnor2.in 2);

		\draw (xnor1.out) -- (and.in 1);
		\draw (xnor2.out) -- (and.in 2);
		\draw (and.out) --++ (0.75, 0) node[label=right:$z$] {};
	\end{circuitikz}
\end{center}
D'ora in poi sarà rappresentato in questo modo
\begin{center}
	\begin{tikzpicture}
		\draw[thick] (-0.75, -0.5) rectangle(0.75, 0.5);
		\node (eq) at (0, 0) {=};

		\draw (-0.5, 1) node[label=above:$x$] {} to[short, o-] (-0.5, 0.5);
		\draw (0.5,  1) node[label=above:$y$] {} to[short, o-] (0.5, 0.5);
		\draw[->, >=Stealth] (0, -0.5) -- (0, -1) node[label=below:$z$] {};
	\end{tikzpicture}
\end{center}
Dove $x$ e $y$ sono entrambe due sequenze da $n$ bit e $z$ vale 0 se $x \neq y$ e vale 1 se $x = y$.

\subsubsection{ALU}
Altro componente fondamentale è la \textbf{ALU}, la quale ci permette di effettuare ben quattro
operazioni tra due sequenze di $n$ bit $x$ e $y$: \verb|AND|, \verb|OR|, somma e sottrazione.

Le prime tre operazioni hanno già un circuito che le implementa e che conosciamo, per la
sottrazione facciamo prima una considerazione.

Come abbiamo già anticipato, se abbiamo un numero positivo rappresentato in complemento a 2, per
farlo diventare negativo dobbiamo negarlo e sommarci 1. Di conseguenza vale che
\[ x - y = x + (\bar{y} + 1) \]
Siamo quindi in grado di utilizzare un addizionatore per svolgere anche le sottrazioni e dunque non
dobbiamo implementare un circuito apposito.
\begin{center}
	\begin{circuitikz}
		\draw[thick] (2, -4.25) -- (2, -2.25) -- (2.75, -2.75) -- (2.75, -3.75) -- cycle;
		\draw[thick] (4, -2.25) -- (4, -1.50) -- (4.25, -1.25) -- (4, -1) --
		(4, -0.25) -- (5, -0.75) -- (5, -1.75) -- cycle;
		\node at (4.625, -1.25) {+};
		\node[or port] (or) at (5, 4) {};
		\node[and port] (and) at (5, 2) {};
		\draw[thick] (7, -1.5) -- (7, 1.5) -- (8, 1) -- (8, -1) -- cycle;

		\draw[->, >=Stealth] (4.625, -5.5) node[label=below:OP] {} to[short, -*] (4.625, -4.75) --
		(2.375, -4.75) -- (2.375, -4);
		\draw[->, >=Stealth] (4.625, -4.75) -- (4.625, -2);
		\draw[->, >=Stealth] (4.625, -4.75) -- (7.5, -4.75) -- (7.5, -1.25);

		\draw[->, >=Stealth] (0, 1) node[label=left:$x$] {} to[short, -*]
		(2.5, 1) -- (2.5, -0.625) -- (4, -0.625);
		\draw (2.5, 1) -- (2.5, 52 |- or.in 1) -- (or.in 1);
		\draw (2.5, 52 |- and.in 1) to[short, *-] (and.in 1);

		\draw[->, >=Stealth] (0, -1) node[label=left:$y$] {} to[short, -*]
		(1.25, -1) -- (1.25, -3.75) to[short, -o] (1.625, -3.75) -- (2, -3.75);
		\draw[->, >=Stealth] (1.25, -2.75) to[short, *-] (2, -2.75);
		\draw (1.25, -1) -- (1.25, 52 |- and.in 2) -- (and.in 2);
		\draw (1.25, 52 |- and.in 2) to[short, *-] (1.25, 52 |- or.in 2) -- (or.in 2);

		\draw[->, >=Stealth] (2.75, -3.25) -- (3.25, -3.25) -- (3.25, -1.875) -- (4, -1.875);
		\draw[->, >=Stealth] (5, -1.25) -- (7, -1.25);
		\draw[->, >=Stealth] (6, -1.25) to[short, *-] (6, -0.5) -- (7, -0.5);
		\draw[->, >=Stealth] (4.5, -0.5) -- (4.5, 0) -- (5, 0);

		\draw[->, >=Stealth] (and.out) -- (5.125, 0.5) -- (7, 0.5);
		\draw[->, >=Stealth] (or.out) -- (6, 52 |- or.out) -- (6, 1) -- (7, 1);
		\draw[->, >=Stealth] (8, 0) -- (8.75, 0);
	\end{circuitikz}
\end{center}
L'entrata OP è un ingresso da 2 bit che ha come funzione principale la selezione dell'operazione
tramite il multiplexer a destra. \`E inoltre usato, nel caso si voglia effettuare una sottrazione
per rendere $y$ negativo tramite il multiplexer iniziale e tramite il riporto immesso
nell'addizionatore.

Supponiamo infatti di avere come configurazione per la scelta delle operazioni della ALU quella
indicata dalla seguente tabella
\begin{center}
	\begin{tabular}{c | c}
		OP input & operazione \\ \hline
		00       & +          \\
		01       & -          \\
		10       & \verb|AND| \\
		11       & \verb|OR|
	\end{tabular}
\end{center}
e inviamo in ingresso $x = 1$, $y = 1$ e $OP = 01$. Dato che $OP = 01$, il primo multiplexer
sceglierà come uscita $\bar{y}$ e invierà all'addizionatore un riporto di 1. Come risultato avremo
che l'addizionatore sommerà $x$ e $\bar{y} + 1$ ottenendo 0. Dato che l'ultimo multiplexer è
impostato per dare come uscita la sottrazione quando $OP = 01$ avremo il risultato richiesto.

\subsubsection{Shift}
In precedenza abbiamo parlato di \textbf{shift logico} e \textbf{shift aritmetico}. Vediamo ora
come è possibile implementare un circuito che ci permette di shiftare a destra una sequenza di bit
di un certo numero di posizioni con una sequenza di esempio di 4 bit.
\begin{center}
	\begin{tikzpicture}
		\draw[thick] (4.25, 3.625) -- (4.25, 1.625) -- (5, 2.125) -- (5, 3.125) -- cycle;

		\draw (0, 5) node[label=above:$x_3$] {} to[short, -*] (0, 4.5) -- (2.5, 4.5);
		\draw (0.5, 5) node[label=above:$x_2$] {} to[short, -*] (0.5, 4.25) -- (2.5, 4.25);
		\draw (1, 5) node[label=above:$x_1$] {} to[short, -*] (1, 4)   -- (2.5, 4);
		\draw (1.5, 5) node[label=above:$x_0$] {} to[short, -*] (1.5, 3.75) -- (2.5, 3.75);


		\draw (2.25, 3.5) node[label=left:\footnotesize0] {} -- (2.5, 3.5);
		\draw (0, 4.5) to[short, -*] (0, 3.25) -- (2.5, 3.25);
		\draw (0.5, 4.25) to[short, -*] (0.5, 3) -- (2.5, 3);
		\draw (1, 4) to[short, -*] (1, 2.75) -- (2.5, 2.75);

		\draw (2.25, 2.5) node[label=left:\footnotesize0] {} -- (2.5, 2.5);
		\draw (2.25, 2.25) node[label=left:\footnotesize0] {} -- (2.5, 2.25);
		\draw (0, 3.25) to[short, -*] (0, 2) -- (2.5, 2);
		\draw (0.5, 3) -- (0.5, 1.75) -- (2.5, 1.75);

		\draw (2.25, 1.5) node[label=left:\footnotesize0] {} -- (2.5, 1.5);
		\draw (2.25, 1.25) node[label=left:\footnotesize0] {} -- (2.5, 1.25);
		\draw (2.25, 1) node[label=left:\footnotesize0] {} -- (2.5, 1);
		\draw (0, 2) -- (0, 0.75) -- (2.5, 0.75);

		\draw[very thick] (2.5, 4.5) -- (2.5, 3.75);
		\draw[very thick] (2.5, 3.5) -- (2.5, 2.75);
		\draw[very thick] (2.5, 2.5) -- (2.5, 1.75);
		\draw[very thick] (2.5, 1.5) -- (2.5, 0.75);

		\draw[->, >=Stealth] (2.5, 4.125) -- (3.5, 4.125) -- (3.5, 3.375) -- (4.25, 3.375);
		\draw[->, >=Stealth] (2.5, 3.125) -- (3, 3.125) -- (3, 2.875) -- (4.25, 2.875);
		\draw[->, >=Stealth] (2.5, 2.125) -- (3, 2.125) -- (3, 2.375) -- (4.25, 2.375);
		\draw[->, >=Stealth] (2.5, 1.125) -- (3.5, 1.125) -- (3.5, 1.875) -- (4.25, 1.875);
		\draw[->, >=Stealth] (4.625, 1) -- (4.625, 1.875);
		\draw[->, >=Stealth] (5, 2.625) --++ (1, 0) node[label=right:$z$] {};
	\end{tikzpicture}
\end{center}
Come è possibile notare quando si shifta a destra si aggiungono tanti 0 a sinistra quanto
necessario e si ridirezionano i bit più significativi. Per uno shift aritmetico a destra avremmo
dovuto collegare l'ingresso del bit più significativo al posto degli 0.

Se avessimo voluto effettuare degli shift a sinistra lo schema sarebbe stato uguale tranne per il
fatto che sarebbero stati i bit più significativi i primi ad andare a 0.

\subsection{Componenti di reti sequenziali}
Le componenti standard implementate sotto forma di rete sequenziale sono di fatto registri e
memorie. In particolare andremo a parlare di
\begin{itemize}
	\item Registri e banchi di registri.
	\item Memorie: statiche, dinamiche e ROM.
\end{itemize}
Dei registri da 1 bit abbiamo già parlato in precedenza, proseguiamo con le altre componenti anche
se riprenderemo il discorso sulle memorie più avanti in modo più approfondito.

\subsubsection{Banco di registri}
I banchi di registri sono una prima forma di \textbf{memoria} in grado di memorizzare più
\emph{parole} le quali sono accessibili tramite un \textbf{indirizzo}. Di seguito un banco da 2
registri.
\begin{center}
	\begin{tikzpicture}
		\draw[->, >=Stealth] (0, 0) node[label=left:EN] {} -- (1, 0); % EN
		\draw[thick] (1, -0.5) -- (1, 0.5) -- (1.5, 0.75) -- (1.5, -0.75) -- cycle; % DEMUX
		\draw[thick] (2.5, 0.75) rectangle (3.5, 0.25); % R1
		\draw[thick] (2.5, -0.75) rectangle (3.5, -0.25); % R2
		\draw[thick] (4.5, -0.75) -- (4.5, 0.75) -- (5, 0.5) -- (5, -0.5) -- cycle; % MUX
		\draw[->, >=Stealth] (5, 0) -- (6, 0) node[label=right:out] {}; % OUT
		\draw[->, >=Stealth] (1.5, 0.375) -- (2.5, 0.375); % demux -> R1
		\draw[->, >=Stealth] (1.5, -0.625) -- (2.5, -0.625); % demux -> R2

		% clock
		\draw[->, >=Stealth, dashed] (1.875, 0.625) -- (2.5, 0.625);
		\draw[->, >=Stealth, dashed] (1.875, -0.375) -- (2.5, -0.375);
		\draw[dashed] (1.875, 1.5) node[label=above:clock] {} -- (1.875, -0.375);

		\draw[->, >=Stealth] (3.5, 0.5) -- (4.5, 0.5); % R1 -> MUX
		\draw[->, >=Stealth] (3.5, -0.5) -- (4.5, -0.5); % R2 -> MUX

		% INPUT
		\draw[->, >=Stealth] (3, 1.5) node[label=above:IN] {} -- (3, 0.75);
		\draw[->, >=Stealth] (3, 1.125) to[short, *-] (4, 1.125) -- (4, 0) -- (3, 0) -- (3, -0.25);

		% INDIRIZZAMENTO
		\draw[->, >=Stealth] (0, -1.25) node[label=left:IND] {} to[short, -*] (1.25, -1.25) --
		(1.25, -0.625);
		\draw[->, >=Stealth] (1.25, -1.25) -- (4.75, -1.25) -- (4.75, -0.625);
	\end{tikzpicture}
\end{center}
Come possiamo vedere, tramite il segnale di IND riusciamo a scrivere IN su uno specifico registro
scelto dal demultiplexer, lo stesso IND viene inviato al multiplexer alla fine per riuscire a
leggere la locazione di memoria indirizzata.

Questo metodo fa uso di registri così come li abbiamo definiti in precedenza e consuma un numero di
transistor molto alto.

\subsubsection{Memorie dinamiche}
Le \textbf{memorie dinamiche} sono implementate in modo tale da permetterci di risparmiare più
transistor ma hanno il continuo bisogno di \emph{"rinfrescare"} il loro contenuto per evitare che
questo vada perso.

Similmente ai banchi di memoria, abbiamo un demultiplexer a cui diamo in ingresso una parola da
scrivere e l'indirizzo a cui scriverla. L'output del demultiplexer è collegato ad una griglia
con un numero di righe pari al numero massimo di parole memorizzabili nella memoria e un numero
di colonne pari alla lunghezza in bit di ognuna delle parole.
\begin{center}
	\begin{tikzpicture}
		\draw[thick] (1, -0.5) -- (1, 0.5) -- (1.5, 0.75) -- (1.5, -0.75) -- cycle; % DEMUX

		% GRID
		\foreach \i in {-0.5, -0.25, 0, 0.25, 0.5}
		\draw[thick] (1.5, \i) -- (3, \i);

		\foreach \i in {1.75, 2, 2.25, 2.5, 2.75}
		\draw[thick] (\i, 0.75) -- (\i, -0.75);

		\draw[->, >=Stealth] (0, 0) node[label=left:IN] {} -- (1, 0);
		\draw[->, >=Stealth] (0, -1) node[label=left:IND] {} -- (1.25, -1) -- (1.25, -0.625);
		\draw[->, >=Stealth] (2.25, -1) -- (2.25, -1.875) node[label=right:OUT] {};
	\end{tikzpicture}
\end{center}
Se volessimo vedere più da vicino la griglia, nello specifico i punti di incrocio, saremmo in grado
di osservare che è presente un transistor il quale si comporta come un condensatore (mantiene una
carica elettrica) e come un interruttore poiché, quando è chiuso, mette in collegamento la riga con
la colonna, viceversa, quando è aperto non c'è alcun contatto.
\begin{center}
	\begin{tikzpicture}
		\draw[thick] (0, 0) -- (1.5, 0);
		\draw[thick] (1.25, 0.25) -- (1.25, -1.25);
		\draw[thick, red] (0.75, 0) -- (1.25, -0.5);
		\draw[->, >=Stealth] (0, -1) node[label=left:transistor] {} -- (0.875, -0.375);
	\end{tikzpicture}
\end{center}
Le linee orizzontali e verticali non si toccano a meno che il transistor non sia chiuso. Quando
facciamo passare un segnale 1 su una certa riga, questo incontra tutti i transistor, per tutti
quelli trovati chiusi, l'1 viene trasmesso sulla rispettiva colonna e inviato in output. Per ogni
transistor aperto, l'1 non si propagherà e dunque avremmo uno 0 in output. In questo modo è
possibile \textbf{leggere} la parola all'indirizzo IND.

Se invece volessimo \textbf{scrivere} una parola all'indirizzo IND dovremmo manipolare i bit sulle
colonne in modo tale che formino la parola desiderata. Come prima inviamo un segnale 1 all'indirizzo
scelto e i transistor chiusi tratterrano una carica elettrica in grado di memorizzare tutti gli 1
della parola. Sui bit messi a 0 i transistor avranno una configurazione aperta e quindi daranno in
output uno 0.

\subsubsection{Memorie statiche}
Le memorie statiche hanno una struttura a griglia come quelle dinamiche ma hanno una struttura più
complessa per quanto riguarda il collegamento tra righe e colonne. Si usano infatti due porte
\verb|NOT| e due transistor (T1 e T2) per la lettura e la scrittura dei bit. Come conseguenze
abbiamo un maggior consumo di spazio sul silicio ma anche una maggiore velocità nell'accesso alla
memoria.
\begin{center}
	\begin{circuitikz}
		\node[not port] (not1) at (0, 1) {};
		\node[not port, rotate=180] (not2) at (0, -1) {};

		\draw (-2, 0) node[label=left:T1] {} -- (-1, 0) -- (-1, 1) -- (not1.in);
		\draw (not1.out) -- (1, 1) -- (1, 0);
		\draw (2, 0) node[label=right:T2] {} -- (1, 0) -- (1, -1) -- (not2.in);
		\draw (not2.out) -- (-1, -1) -- (-1, 0);
	\end{circuitikz}
\end{center}
Inotre non è più necessario \emph{rinfrescare} il contenuto della memoria in continuazione poiché
questo tipo di memoria è in grado di trattenere l'informazione in modo autonomo.

\subsubsection{Considerazioni sulle RAM}
Queste appena descritte sono dette memorie \textbf{RAM} (Random Access Memory) poiché non è
necessario leggere tutte le locazioni in sequenza ma possiamo accedere direttamente alla locazione
desiderate. Comparando i tre tipi di RAM che abbiamo visto fino ad ora possiamo dire che
\begin{itemize}
	\item I registri sono i più veloci per quanto riguarda lettura e scrittura ma sono quelli
	      occupano più spazio sul silicio a parità di capienza.
	\item Le memorie dinamiche sono quelle più lente ma che occupano meno spazio sul silicio.
	\item Le memorie statiche si collocano a metà tra queste due per quanto riguarda velocità e
	      spazio occupato.
\end{itemize}
A seconda dell'uso che se ne fa e dei contesti sarà necessario scegliere un tipo di RAM piuttosto
che l'altro.

\subsubsection{ROM}
Le \textbf{ROM} (Read Only Memory) sono molto simili, come struttura, alle RAM viste fino ad ora
ma non abbiamo alcun meccanismo di controllo sui transistor che collegano le righe alle colonne
della griglia. Abbiamo un collegamento diretto (nel caso volessimo trasmettere un 1) oppure
l'assenza di quest'ultimo (nel caso volessimo trasmettere uno 0).

\subsubsection{Memorie modulari}
Da questo momento considereremo i registri come una sorta di vettore di registri, il quale prende
ad esempio in input tre indirizzi e ha 2 uscite. Questo perché se, come vedremo più avanti, in
assembler volessimo eseguire un'operazione di \verb|ADD| tra un registro \verb|R2| e un registro
\verb|R3| e volessimo salvare il risultato in un registro \verb|R1|, questo schema ci sarà molto
utile
\begin{center}
	\begin{tikzpicture}
		\draw[thick] (-0.5, -0.5) rectangle (0.5, 0.5);
		\node at (0, 0) {\footnotesize{REG}};
		\draw[->, >=Stealth] (-1.5, 0.25) node[label=left:\scriptsize{IND1}]	{} -- (-0.5, 0.25);
		\draw[->, >=Stealth] (-1.5, 0) node[label=left:\scriptsize{IND2}] {} -- (-0.5, 0);
		\draw[->, >=Stealth] (-1.5, -0.25) node[label=left:\scriptsize{IND3}]{} -- (-0.5, -0.25);

		\draw[->, >=Stealth] (-1.5, 0.75) node[label=left:\scriptsize{IN}] {} -- (0, 0.75) -- (0, 0.5);

		\draw[->, >=Stealth] (0.5, 0.25) -- (1.5, 0.25) node[label=right:\scriptsize{OUT1}] {};
		\draw[->, >=Stealth] (0.5, -0.25) -- (1.5, -0.25) node[label=right:\scriptsize{OUT2}] {};
	\end{tikzpicture}
\end{center}
Possiamo quindi leggere o scrivere più indirizzi di memoria in un singolo ciclo di clock. Per le
RAM invece dobbiamo, in generale, eseguire più cicli di clock. Possiamo anche vedere le memorie
come moduli di parole da $n$ bit, concatenabili e a cui è possibile inviare in uno stesso ciclo di
clock lo stesso indirizzo e il segnale di \verb|ENABLE|. In questo modo otteniamo una parola che
è più lunga del singolo modulo.

Se ad esempio avessimo a disposizione moduli da 1M parole di 32 bit e volessimo una memoria da 2M
parole, sarebbe possibile concatenare due di questi moduli.

Prima di tutto consideriamo che per indirizzare 1M servono $\log_2 (1 \times 10^6) = 20$ bit,
quindi per indirizzarne 2 servono 21 bit. Avremmo quindi 1 bit che sceglie quale dei due moduli
andare a leggere o scrivere e i restanti bit che andranno ad accedere la locazione di memoria
corretta.

% CIRCUITO

Se il bit che determina quale modulo andare a leggere o scrivere è il più significativo parleremo
di memoria modulare \textbf{sequenziale}, il cui schema logico è il seguente
\begin{center}
	\begin{tikzpicture}
		\draw[thick] (0, 0) rectangle (1, 2);
		\draw[thick] (3, 0) rectangle (4, 2);

		\foreach \i in {1.5, 1, 0.5}{
				\draw[thick] (0, \i) -- (1, \i);
				\draw[thick] (3, \i) -- (4, \i);
			}

		\node at (0.5, 1.75) {0};
		\node at (0.5, 1.25) {1};
		\node at (0.5, 0.75) {2};
		\node at (0.5, 0.25) {3};

		\node at (3.5, 1.75) {4};
		\node at (3.5, 1.25) {5};
		\node at (3.5, 0.75) {6};
		\node at (3.5, 0.25) {7};
	\end{tikzpicture}
\end{center}
Se invece il bit in questione fosse il meno significativo dell'indirizzo quella che otteniamo è una
memoria modulare \textbf{interlacciata}, il cui schema logico è il seguente
\begin{center}
	\begin{tikzpicture}
		\draw[thick] (0, 0) rectangle (1, 2);
		\draw[thick] (3, 0) rectangle (4, 2);

		\foreach \i in {1.5, 1, 0.5}{
				\draw[thick] (0, \i) -- (1, \i);
				\draw[thick] (3, \i) -- (4, \i);
			}

		\node at (0.5, 1.75) {0};
		\node at (0.5, 1.25) {2};
		\node at (0.5, 0.75) {4};
		\node at (0.5, 0.25) {6};

		\node at (3.5, 1.75) {1};
		\node at (3.5, 1.25) {3};
		\node at (3.5, 0.75) {5};
		\node at (3.5, 0.25) {7};
	\end{tikzpicture}
\end{center}
Come possiamo vedere, in questo caso abbiamo che le locazioni di memoria sono enumerate saltando
costantemente da un modulo all'altro. Questo significa che se avessimo bisogno di scrivere in
memoria una parola da 64 bit potremmo farlo andando a scrivere prima nella locazione $m_i$ e poi in
quella $m_{i+1}$ che si troverà sull'altro modulo ma allo stesso livello.

Se adessimo eliminassimo il multiplexer alla fine del circuito mostrato in precedenza otterremmo
due uscite da 32 bit, ognuna con metà della parola da 64 bit. \`E quindi possibile leggere due
parole in un singolo ciclo di clock in questo modo.

Con il modello sequenziale avremmo avuto bisogno di due cicli di clock in quanto la locazione
$m_{i+1}$ si sarebbe trovata all'interno dello stesso modulo.
