\section{Verilog}
Introduciamo brevemente il linguaggio \textbf{Verilog} per la simulazione ed implementazione di
piccole reti logiche. Nello specifico andremo a vedere com'è possibile implementare i circuiti
visti fino ad ora, senza specificare come funziona il linguaggio. Iniziamo con il rappresentare un
circuito qualsiasi tramite la sua tabella di verità.
\begin{minted}{verilog}
primitive rete(output out, input a, input b);
	table
		0 0 : 1;
		0 1 : 1;
		1 0 : 1;
		1 1 : 0;
	endtable
endprimitive
\end{minted}
In verilog, una \verb|primitive| può avere più ingressi ma una sola uscita, quindi nel caso
avessimo bisogno di una tabella di verità a più uscite dovremmo riscrivere una \verb|primitive| per
ogni uscita.

Dalla tabella di verità scritta sopra è possibile estrapolare un'espressione dell'algebra booleana
nel modo descritto nei paragrafi precedenti, ottenendo
\[ z = \bar{x} \bar{y} + \bar{x} y + x \bar{y} \]
In verilog possiamo usare una sintassi che ci permette di scrivere espressioni booleane in questo
modo
\begin{minted}{verilog}
module rete(output out, input a, input b);
	assign out = ~a & ~b | ~a & b | a & ~b;
endmodule
\end{minted}
A questo punto non ci rimane che testare la nostra rete tramite un programma "\verb|main|" che
possiamo definire in questo modo
\begin{minted}{verilog}
module test();
	reg a, b;
	wire out;
	rete r(out, a, b); // istanziazione della rete 
	
	initial begin // main
		$dumpfile("test.vcd"); // file con i risultati delle simulazione
		$dumpvars;

		a = 0; b = 0; #3 // attendi 3 unità di tempo
		b = 1; #3
		a = 1; b = 0; #3
		b = 1; #5
		$finish; // fine simulazione
	end
endmodule
\end{minted}
Come abbiamo già fatto possiamo però usare le regole dell'algebra booleana per semplificare
l'espressione
\[ z = \bar{x} \bar{y} + \bar{x} y + x \bar{y} \]
e farla diventare
\[ z = \bar{x} + \bar{y} \]
e dunque possiamo creare un altro modulo di questo tipo
\begin{minted}{verilog}
module rete(output out, input a, input b);
	assign z = ~a | ~b;
endmodule
\end{minted}
che calcola la stessa cosa di prima.

\subsection{Multiplexer}
Vogliamo ora implementare un multiplexer come quello visto in precedenza, in cui si hanno tre
ingressi, $x$, $y$ e $c$ e una sola uscita $z$ che dipende da $c$. Come in precendenza, possiamo
scrivere una forma contratta della tabella di verità tramite il simbolo \verb|?| per indicare i
valori \textbf{non specificati}.
\begin{minted}{verilog}
primitive multiplexer(output out, input c, input a, input b);
	table
		0 0 ? : 0;
		0 1 ? : 1;
		1 ? 0 : 0;
		1 ? 1 : 1;
	endtable
endprimitive
\end{minted}
Se volessimo riscrivere la cosa in forma di algebra booleana abbiamo
\begin{minted}{verilog}
module multiplexer(output out, input c, input a, input b);
	assign out = ~c & a | c & b;
endmodule
\end{minted}
In maniera molto simile a prima testiamo il nostro circuito con un modulo che non fa altro che
provare tutte le possibili combinazioni dei valori di \verb|a|, \verb|b| e \verb|c|.

\subsection{Addizionatore}
Nel caso volessimo implementare un \textbf{addizionatore} di due sequenze, entrambe da 2 bit, le
cose si complicano leggermente in quanto abbiamo bisogno di un modo per manipolare più bit
aggregati.