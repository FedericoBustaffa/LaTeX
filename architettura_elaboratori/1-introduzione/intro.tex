\chapter{Introduzione}
Tutti i calcolatori moderni possono essere schematizzati semplicemente tramite il cosiddetto
\textbf{modello Von Neumann} in cui abbiamo tre componenti principali: \textbf{memoria},
\textbf{processore} e canali di \textbf{I/O}.

\begin{center}
	\begin{tikzpicture}[scale=1.5]
		\node[draw] (mem) at (0, 0) {Memoria};
		\node[draw] (cpu) at (0, -1.5) {CPU};
		\node[draw] (io) at (2, -1.5) {I/O};

		\draw[<->] (mem) -- (cpu);
		\draw[<->] (cpu) -- (io);
	\end{tikzpicture}
\end{center}

Come possiamo vedere dalla figura i collegamenti tra le varie entità sono bidirezionali. Il
processore (ma anche la memoria) è collegato ai canali di I/O e il collegamento che c'è tra memoria
e processore è chiamato \textbf{Von Neumann bottleneck}. Quello che accade tra memoria e processore
è, grosso modo, quello che viene descritto dal seguente pseudocodice ed è denominato ciclo di
\textbf{fetch-decode-execute}.

\begin{minted}{c}
while (true) {
	istr = M[PC]
	decode(istr)
	res = exec(istr)
	update(PC)
	writeback(res)
	interrupt_handling()
}
\end{minted}

In pratica viene estratta dalla memoria l'istruzione puntata da un \textbf{Program Counter}, la
si decodifica e la si esegue. In seguito il Program Counter viene aggiornato e i risultati vengono
consolidati nei registri della CPU oppure in memoria.

Per ognuna delle istruzioni eseguite sul canale presente tra processore e memoria vengono svolte
le seguenti operazioni
\begin{enumerate}
	\item Il processore manda un indirizzo (PC) dove andare a prendere l'istruzione.
	\item La memoria risponde con un'istruzione.
	\item Il processore esegue e durante l'esecuzione può richiedere la lettura o scrittura dalla
	      memoria.
\end{enumerate}
Questo processo avviene molto spesso e rende il traffico sul canale molto intenso creando per
l'appunto un \emph{collo di bottiglia}. Questo è dovuto alla rapida evoluzione dei processori e
alla non altrettanto rapida evoluzione della memoria, la quale ha una velocità nel fornire le
istruzioni minore della velocità che impiega il processore ad eseguirle e richiederne altre.

Per misurare le performance di un processore siamo abituati a ragionare in termini di
\textbf{cicli di clock}. Dato che, approssimativamente, possiamo dire che un ciclo di clock
corrisponde ad un'istruzione eseguita, se ad esempio abbiamo un processore a 1 GHz, questo riuscirà
ad eseguire un'istruzione in 1 nanosecondo.

Durante il corso verrano trattate varie architetture, dalle prime progettate alle più recenti,
cercando di capire come funzionano e i loro pregi e difetti. Tra quelle che tratteremo elenchiamo
\begin{itemize}
	\item \textbf{Single cycle}: modello in cui un ciclo fetch-execute viene effettuato in un ciclo
	      di clock.
	\item \textbf{Pipeline}: modello in cui si hanno componenti distinte per le operazioni di fetch,
	      decode ed execute. In questo modo ogni componente continua a svolgere il proprio lavoro
	      parallelamente alle altre. Una volta arrivato a regime questo processore riesce a
	      eseguire un'istruzione all'inizio di ogni ciclo di clock e non alla fine (come nel
	      modello single cycle).
\end{itemize}