\section{Memoria virtuale}
Come dovrebbe essere chiaro, quando compiliamo un programma questo possiede alcune informazioni
necessarie per la sua esecuzione. Tra queste abbiamo gli indirizzi ai quali è possibile trovare
istruzioni e dati del nostro eseguibile.

Quando eseguiamo un programma questo viene caricato in memoria principale utilizzando tali indirzzi
e sempre tramite gli stessi indirizzi è possibile andare a reperire, all'occorrenza, istruzioni e
dati.

Ovviamente gli indirizzi che un programma si porta dietro non sono assoluti, non andiamo quindi a
specificare l'esatto indirizzo in memoria fisica poiché si dovrebbe ricompilare il programma ogni
volta per ottenere sempre nuovi indirizzi.

Quello che si fa è assegnare a istruzioni e dati del nostro programma degli
\textbf{indirizzi virtuali}. Per farla semplice, se il nostro programma ha $n$ istruzioni, la prima
istruzione ha indirizzo 0 e l'ultima ha indirizzo $n-1$.

Dato che però tutti i programmi sono compilati in questo modo, abbiamo bisogno di un modo per
tradurre indirizzi virtuali (o logici) in \textbf{indirizzi fisici}.

\subsection{Paginazione}
Per la precisione non andiamo a caricare in memoria le istruzioni una per una, ma andiamo a caricare
delle \textbf{pagine}, ossia porzioni tutte uguali (in genere 4KB) del nostro codice in memoria,
anch'essa divisa in pagine della stessa dimensione.

Quando vogliamo caricare una pagina in memoria traduciamo l'indirizzo della prima istruzione della
pagina in un indirizzo fisico della memoria principale, basandoci sulle pagine libere di
quest'ultima.

La corrispondenza tra indirizzo virtuale e indirizzo fisico viene memorizzata nella
\textbf{tabella delle pagine}, di cui è provvisto ogni processo che carichiamo in memoria.
\begin{center}
	\includesvg[inkscapelatex=false, scale=0.8]{circuiti/paginazione.svg}
\end{center}
Questo metodo ci permette di allocare pagine in memoria principale senza che esse siano contigue.

\subsubsection{TLB}
Possiamo supporre che il contenuto della tabella delle pagine rimanga tale fin tanto che il
programma è in esecuzione.

Vogliamo però definire un \textbf{working set}, ossia un insieme di istruzioni e dati utili in un
certo tempo dell'esecuzione del programma, e metterli in una cache. Questa cache ci aiuta nella
traduzione degli indirizzi e ci permette di evitare di accedere l'intera tabella delle pagine.

La cache adottata per questo tipo di lavoro è detta \textbf{TLB} (Translation Lookaside Buffer) ed
è una cache completamente associativa che mantiene delle entry con le associazioni tra pagine
logiche e pagine fisiche e, per ognuna di esse, un bit di validità.

Per riuscire ad accedere una certa istruzione o dato, abbiamo bisogno di un indirizzo composto dal
numero di pagina logica e dall'offset per capire di quanto muoversi all'interno di tale pagina.

In maniera analoga a ciò che abbiamo visto per le cache associative, possiamo dividere la logica
che implementa la cache in una parte adibita alla gestione dei fault
\begin{center}
	\includesvg[inkscapelatex=false, scale=0.7] {circuiti/tlb.svg}
\end{center}
e in una parte per l'elaborazione del risultato (in questo caso la pagina fisica) la quale prende
le uscite degli \verb|AND| di sopra e le manda in un codificatore che genererà il segnale di
controllo per un multiplexer che andrà a produrre infine l'indirizzo di pagina fisica desiderato.