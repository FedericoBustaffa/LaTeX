\section{Istruzioni}
L'assembler è un linguaggio a basso livello con il quale possiamo programmare il nostro processore
eseguendo \textbf{istruzioni}
\begin{itemize}
	\item Di \textbf{operative}: come somme, sottrazioni, shift, operazioni booleane e così via.
	      Tali istruzioni operano sui registri interni al processore.
	\item Di \textbf{accesso alla memoria} per manipolare i dati dai registri alla memoria e
	      viceversa.
	\item Di \textbf{controllo} o \textbf{salto}: costrutti equivalenti a \verb|IF-THEN-ELSE| e
	      chiamate di funzione.
\end{itemize}

\subsection{Registri}
I registri, in ARMv7, sono 16 (da 0 a 15), quelli da 0 a 12 hanno delle convenzioni ma sono sotto
il completo controllo dell'utente, mentre gli ultimi tre sono registri \emph{speciali}:
\begin{itemize}
	\item \textbf{PC}: è il \textbf{program counter}, il quale contiene l'indirizzo dell'istruzione
	      da eseguire.
	\item \textbf{SP}: è lo \textbf{stack pointer}, utile per memorizzare l'indirizzo su cui si
	      trova l'ultimo elemento inserito nello \emph{stack}.
	\item \textbf{LR}: è il \textbf{link register} che viene utilizzato per le chiamate di funzione
	      per mantenere l'\emph{indirizzo di ritorno}.
\end{itemize}
I restanti registri sono di più libero uso ma l'assembler ARM definisce delle \textbf{convenzioni}
su di essi
\begin{itemize}
	\item I registri da 0 a 3 sono riservati per valori temporanei o per parametri di chiamate di
	      funzione. Solitamente il registro 0 viene usato per il valore di ritorno di una funzione,
	      mentre da 1 a 3 sono utilizzati come parametri attuali in una chiamata di funzione.
	\item I registri da 4 a 11 servono a memorizzare le variabili. Dopo il loro utilizzo dobbiamo
	      garantire che questi tornino ad avere il valore che avevano prima che venissero
	      utilizzati salvandoli sullo stack.
\end{itemize}
Attenersi a tali convenzioni aiuta a garantire l'interoperabilità.

\subsection{Istruzioni operative}
Le istruzioni \textbf{operative} prendono come argomenti tre registri, il primo sarà il registro di
\textbf{destinazione} e gli altri due saranno i registri \textbf{sorgente} da cui prenderemo i
valori necessari a svolgere l'operazione desiderata. Tra le istruzioni più importanti abbiamo le
operazioni di \textbf{calcolo}
\begin{itemize}
	\item \verb|ADD| e \verb|ADC|: addizione e addizione con riporto.
	\item \verb|SUB| e \verb|RSB|: sottrazione e sottrazione inversa.
\end{itemize}
Tra le istruzioni \textbf{logiche} abbiamo invece
\begin{itemize}
	\item \verb|AND|: \verb|AND| logico
	\item \verb|ORR|: \verb|OR| logico
	\item \verb|EOR|: \verb|XOR|, sta per Exclusive OR.
	\item \verb|BIC|: operazione di \emph{bit clear} la quale cancella dal secondo parametro i bit
	      a 1 del terzo parametro.
\end{itemize}
Le istruzioni di \textbf{shift} sono sia di tipo logico che aritmetico
\begin{itemize}
	\item \verb|LSL| e \verb|LSR|: rispettivamente shift logico a sinistra e a destra.
	\item \verb|ASL| e \verb|ASR|: rispettivamente shift aritmetico a sinistra e a destra.
	\item \verb|ROR|: shift ciclico in cui i bit più a destra rientrano da sinistra.
\end{itemize}
Le istruzioni di \textbf{moltiplicazione} sono molteplici:
\begin{itemize}
	\item \verb|MUL|: come le altre istruzioni accetta tre parametri ma dato che il risultato
	      sarebbe un numero a 64 bit considera solo i 32 bit meno significativi.
	\item \verb|SMULL| e \verb|UMULL|: che eseguono rispettivamente la moltiplicazione per numeri
	      con e senza segno ma stavolta mettono il risultato in due registri (infatti necessitano
	      di quattro parametri di cui i primi due sono le destinazioni) restituendo così un valore
	      a 64 bit.
\end{itemize}
Per quanto riguarda \textbf{la divisione non è supportata} nativamente dobbiamo quindi
implementarla in qualche modo.

Come ultima istruzione vediamo l'\textbf{assegnamento} (\verb|MOV|) che prende solo due parametri,
la destinazione e la sorgente, andando a scrivere il valore della sorgente nella destinazione.

\subsection{Istruzioni di accesso alla memoria}
Per l'accesso alla memoria abbiamo due istruzioni principali (\verb|LOAD| e \verb|STORE|), le quali
servono a muovere i dati dalla memoria ai registri e viceversa:
\begin{itemize}
	\item \verb|LDR|: da memoria a registro.
	\item \verb|STR|: da registro a memoria.
\end{itemize}
L'istruzione di \verb|LOAD| prende come primo parametro un registro che sarà la destinazione,
mentre la \verb|STORE| prenderà come primo parametro un registro che sarà la sorgente di cui
leggeremo il contenuto.

I parametri dopo il primo, sia per l'una che per l'altra istruzione possono variare a seconda dei
casi, e servono ad definire l'indirizzo da cui leggere o scrivere dati.
\begin{minted}{gas}
ldr r0, [r1]
\end{minted}
va a leggere il contenuto della memoria all'indirizzo scritto in \verb|r1| e lo scrive in \verb|r0|.
Supponiamo però di avere in \verb|r1| l'indirizzo in cui è presente un array, se volessimo prendere
un valore all'interno dell'array senza perdere l'indirizzo in \verb|r1| possiamo fare in questo
modo
\begin{minted}{gas}
ldr r0, [r1, r2]
\end{minted}
andando a specificare con \verb|r2| un offset e andando di fatto a leggere la memoria all'indirzzo
\verb|r1 + r2| lasciando questi ultimi invariati. Al posto di \verb|r2| possiamo usare anche una
costante numerica.

La memoria in ARMv7 è \textbf{indirizzata al byte} e dato che consideriamo locazioni di memoria da
32 bit, ossia 4 byte, l'operazione
\begin{minted}{gas}
ldr r0, [r1, #4]
\end{minted}
non legge il quarto elemento dell'array ma il secondo (abbiamo cioè un offset di una posizione).
Per gestire gli indici in maniera più ragionevole esiste anche un altro modo per l'accesso alla
memoria
\begin{minted}{gas}
ldr r0, [r1, r2, LSL #2]
\end{minted}
che va a leggere la memoria all'indirizzo $r1 + r2 \times 4$. Supponiamo ora di voler scrivere in
ARM un codice che in C scriveremmo in questo modo
\begin{minted}{c}
int x[16];
sum = x[0] + x[1];	
\end{minted}
Supponiamo ora che la base di \verb|x| sia in \verb|r1| e vogliamo usare \verb|r2| come indice,
quello che scriveremmo in ARM sarebbe
\begin{minted}{gas}
mov r2, #0
ldr r3, [r1, r2]
add r2, r2, #4
ldr r4, [r1, r2]
\end{minted}
In termini più generali possiamo scrivere
\begin{minted}{gas}
ldr r3, [r1, r2]
add r2, r2, #1
ldr r3, [r1, r2, lsl #2]
\end{minted}
Dato che scorrere la memoria in modo sequenziale accade molto spesso abbiamo a disposizione dei
costrutti che compattano il codice incrementando l'indice in automatico di una locazione di memoria
\begin{minted}{gas}
ldr r0, [r1, r2]!
\end{minted}
Questo di sopra è un meccanismo detto \textbf{pre-index} che va a mettere in \verb|r0| il contenuto
della memoria all'indirizzo $r1 + r2$ e implicitamente mettiamo in \verb|r1| il valore di $r1 + r2$.
In alternativa abbiamo il meccanismo di \textbf{post-index}
\begin{minted}{gas}
ldr r0, [r1], r2
\end{minted}
che, a differenza del pre-index, mette in \verb|r0| il valore in memoria all'indirizzo \verb|r1| e
solo dopo aggiorna \verb|r1| con $r1 + r2$.

Altre due implementazioni delle istruzioni di \verb|LOAD| e \verb|STORE| sono \verb|LDRB| e
\verb|STRB| le quali caricano il primo byte indirizzato nella parte meno significativa del registro.

Esistono anche delle istruzioni per l'assegnamento multiplo