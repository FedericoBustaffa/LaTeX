\section{Multiprocessing e memoria condivisa}

Il modulo \verb|multiprocessing| di Python mette a disposizione varie
funzionalità per la condivisione dei dati tramite memoria condivisa.

La memoria in questione viene allocata al di fuori dello spazio di memoria dei
vari processi ma è comunque visibile e modificabile dagli stessi. Il tutto in
modo diretto e senza la necessità di coinvolgere meccanismi streaming dei dati.

Il modello di calcolo risulta quindi essere differente da uno in cui si fa uso
di meccanismi di stream, come ad esempio le pipe.

Prima di iniziare facciamo alcune rapide considerazioni. Per riuscire a
sfruttare al meglio il parallelismo e generare meno overhead possibile,
dobbiamo tenere di conto che:
\begin{itemize}
	\item \textbf{Generazione dei processi}: I processi richiedono tanto tempo
	      per essere istanziati. Non è quindi pensabile un approccio in cui
	      questi vengono creati all'inizio di ogni iterazione e distrutti alla
	      fine della stessa.
	\item \textbf{Memoria}: I processi occupano più memoria. Per il momento non
	      so quanto questo sia impattante. Probabilmente non sarà mai un vero e
	      proprio problema in quanto il numero di processi in genere non supera
	      il numero di core della macchina ed è ragionevole pensare che, per
	      una macchina con un numero considerevole di core, non sia un problema
	      la memoria.
	\item \textbf{Strutture dati}: Le strutture dati, soprattutto quelle
	      condivise tra i processi, dovrebbero subire modifiche mirate e il
	      meno impattanti possibile. Questo sia per evitare possibile
	      comportamenti indesiderati, sia per migliorare le prestazioni.
\end{itemize}
Punteremo quindi ad un approccio che mira a sfruttare al meglio le risorse già
preallocate e meccanismi come il \emph{caching}.

\subsection{Modello}

La struttura del modello di calcolo per il momento è molto semplice e dovrebbe
essere un qualcosa del genere:

\begin{wrapfigure}{r}{0.35\textwidth}
	\includesvg[inkscapelatex=false, scale=0.3625]{images/schema1.svg}
\end{wrapfigure}

Come possiamo vedere in figura, quello che si vuole riuscire ad eseguire in
parallelo solo le fasi di crossover, mutazione e valutazione. Il fatto che
siano una dopo l'altra, come possiamo vedere, ci agevola molto in quanto si
minimizzano il numero di processi coinvolti e si ottiene un bel guadagno in
termini di prestazioni.

Percorriamo brevemente l'algoritmo per capire quali strutture dati sono
coinvolte:

\begin{enumerate}
	\item Viene generata una \textbf{lista di individui} e viene valutata.
	\item Vengono selezionati gli individui per la riproduzione e si produce
	      una \textbf{lista degli indici} degli individui selezionati.
	\item La lista di indici generata viene usata per creare le coppie di
	      genitori. Questa fase non può essere eseguita in parallelo perché
	      la scelta dei genitori viene fatta casualmente su tutta la lista
	      dei selezionati.
\end{enumerate}