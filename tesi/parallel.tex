\section{Algoritmo}

Cerchiamo ora di definire un algoritmo genetico sequenziale che sia una buona
base per quello che andremo a fare dopo. Si vuole infatti costruire un modello
su cui basare le possibili implementazioni che andremo a studiare.

\subsection{API e utilizzo}

Per quanto riguarda l'API messa a disposizione dell'utente vogliamo un qualcosa
che sia il più semplice possibile e che prevenga errori o cattiva gestione
delle strutture dati, fondamentali per la corretta esecuzione dell'algoritmo.

L'idea sarebbe quella di istanziare l'algoritmo come un oggetto, al quale
verranno forniti i vari metodi che compongono un algoritmo genetico.

\begin{minted}{py}
from genetic import GeneticAlgorithm

if __name__ == "__main__":
	ga = GeneticAlgorithm(
		population_size
		gen_func,
		selection_func,
		crossover_func,
		mutation_func,
		fitness_func,
		replacement_func,
		convergence_func
	)

	ga.run()
	results = ga.get()
\end{minted}

In questo modo non si espongono le strutture dati all'esterno della classe se
non come copie o come \emph{viste} dell'originale. Questo rende anche possibile
il riutilizzo di strutture dati già allocate andando rendere più efficiente
l'algoritmo in un senso che sarà più chiaro andando avanti.

\subsection{Cromosomi}

Prima di definire le varie fasi dell'algoritmo, introduciamo brevemente come
vengono rappresentati i \textbf{cromosomi}.

\begin{minted}{py}
class Chromosome:
	def __init__(self, values, fitness) -> None:
		self.values = values
		self.fitness = fitness
\end{minted}

Ogni cromosoma rappresenta un individuo della popolazione, il quale è
generalmente identificato da un vettore di valori numerici e da un valore di
fitness.

Noi tratteremo solo casi in cui abbiamo vettori numerici, sarà poi compito del
programmatore mappare il cromosoma in ciò che gli serve per risolvere il
problema di interesse.

\subsection{Generazione della popolazione iniziale}

In questa prima fase andiamo a generare una popolazione iniziale di $N$
individui in modo del tutto casuale. Evitare di generare duplicati è buona
norma, almeno in questa fase, così da garantire un alto grado di
\emph{biodiversità} iniziale.

\begin{minted}{py}
	def __generate(self) -> None:
		for i in range(N):
			values = self.gen_func()
			while values in population:
				values = self.gen_func()
			self.population[i].values = values
\end{minted}

Per la fase iniziale di generazione, lasciamo al programmatore il compito di
definire come viene generato il singolo cromosoma. Sarà poi il modulo ad
occupersi di gestire i duplicati e memorizzare la popolazione.

\subsection{Selezione}

Le possibili implementazioni della fase di selezione degli individui per
l'accoppiamento sono molto varie e potrebbero non avere parti in comune.

Prendiamo ad esempio la selezione a \emph{torneo} in cui si scelgono a due a
due degli individui e quello con fitness più alta viene scelto.

In una soluzione a \emph{roulette} invece gli individui vengono scelti
singolarmente e volta per volta. In ogni caso si lavora sempre sull'intera
popolazione e non ci sono parti facilmente \emph{generalizzabili}.

Ecco perché in questa fase si richiede al programmatore di implementare la fase
di selezione per intero.

\begin{minted}{py}
	def __selection(self):
		self.selected[:] = self.selection_func(self.population)
\end{minted}

