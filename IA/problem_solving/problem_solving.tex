\chapter{Problem solving}
\section{Formulazione di un problema}
\subsection{Agenti risolutori di problemi}
Gli \textbf{agenti risolutori di problemi} adottano il paradigma della risoluzione di
problemi come \textbf{ricerca} in uno \textbf{spazio di stati}.

Sono agenti basati su modello e con obbiettivo che adottano una rappresentazione
\textbf{atomica} dello stato e pianificano l'intera sequenza di mosse prima di agire.

\subsection{Processo di risoluzione}
Il processo di risoluzione di un problema si compone di quattro passi principali:
\begin{enumerate}
	\item Determinazione dell'obbiettivo.
	\item Formulazione del problema, che consiste nella rappresentazione di
	      \begin{itemize}
		      \item stati
		      \item azioni
	      \end{itemize}
	\item Determinazione della soluzione mediante \textbf{ricerca}
	\item Esecuzione del piano.
\end{enumerate}

\subsection{Assunzioni sull'ambiente}
Per adesso assumiamo che l'ambiente sia:
\begin{itemize}
	\item Statico
	\item Osservabile
	\item Discreto
	\item Deterministico
\end{itemize}

\subsection{Formulazione del problema}
Un problema pu\`o essere definito formalmente con queste cinque componenti:
\begin{description}
	\item[Stato iniziale:] Lo stato da cui si parte.
	\item[Azioni possibili:] Dipendono dallo stato corrente e portano in un nuovo stato.
	\item[Modello di transizione:] Descrizione dello spazio degli stati e come si effettua
	      la transizione dall'uno all'altro.
	\item[Test obbiettivo:] Ho un insieme di stati obbiettivo e devo verificare se gli stati
	      che ho raggiunto sono quelli nell'insieme obbiettivo oppure no.
	\item[Costo del cammino:] \`E la somma del costo delle azioni (transizioni di stato).
\end{description}

\section{Algoritmi di ricerca}
Gli \textbf{algoritmi di ricerca} prendono in input un problema e restituiscono un
\textbf{cammino soluzione}, ovvero un cammino che porta dallo stato iniziale ad uno stato
obbiettivo.

Vengono valutati in base al \textbf{costo di ricerca} di una soluzione e anche
all'\textbf{efficienza} della soluzione trovata.

\subsection{Ricerca della soluzione}
Per trovare una soluzione si genera un \textbf{albero di ricerca} sovrapposto allo spazio
degli stati (generato da possibili azioni).

Ma come si genera l'albero di ricerca ?
\begin{enumerate}
	\item La radice dell'albero corrisponde allo stato iniziale.
	\item Ad ogni passo si sceglie una foglia dell'albero generato fino a quel momento.
	\item Le foglie costituiscono la \textbf{frontiera}.
	\item Ogni volta che visitiamo una foglia \textbf{espandiamo} tale nodo.
\end{enumerate}
Dobbiamo chiarire che un \emph{nodo} e uno \emph{stato} non sono la stessa cosa. Uno stato
\`e un'osservazione sul mondo del problema. Un nodo \`e una componente dell'albero di
ricerca e pu\`o capitare di avere pi\`u nodi con lo stesso stato.

\subsubsection{Ricerca ad albero}
Quello che facciamo in questo caso \`e una \textbf{visita} dello spazio degli stati finch\'e non
si giunge allo \textbf{stato obbiettivo} o finch\'e, dopo aver visitato tutti gli stati, ci
rendiamo conto di aver esplorato tutto lo spazio degli stati (o almeno quello esplorabile
partendo dallo stato fornito in partenza).

Per fare la visita avremo bisogno di un buffer che chiameremo \textbf{frontiera}, dove metteremo
gli stati adiacenti a quello corrente che intendiamo visitare.

\newpage
L'algoritmo procede in questo modo:
\begin{enumerate}
	\item Si sceglie uno stato iniziale e si mette nella frontiera.
	\item Si entra in un ciclo da cui si pu\`o uscire solo in due modi:
	      \begin{itemize}
		      \item Si trova la soluzione.
		      \item Si esaurisce tutto lo spazio degli stati senza trovare la soluzione (quindi
		            non esiste).
	      \end{itemize}
	\item Verifichiamo che la frontiera non sia vuota, se lo \`e abbiamo esaurito tutti gli
	      stati visitabili e quindi non c'\`e una soluzione e l'algoritmo termina con
	      fallimento.
	\item Si estrae un nodo dalla frontiera e controlliamo se lo stato \`e equivalente allo
	      stato obbiettivo, se s\`i, l'algoritmo termina ritornando la soluzione.
	\item Si inseriscono tutti i nodi figlio del nodo corrente nella frontiera.
	\item Si torna al punto 2.
\end{enumerate}
\begin{lstlisting}[style=pseudo-style]
Ricerca_albero (problema)
	// inizializzazione frontiera con lo stato iniziale
	radice = problema.statoIniziale;
	frontiera.push(radice);
	while true
		// non esiste una soluzione
		if frontiera.isEmpty() then
			return FALLIMENTO;
		
		// prendo un nodo dalla frontiera
		nodo = frontiera.pop();
		
		// nel caso in cui si trovi il nodo obbiettivo
		if nodo.stato == problema.statoObbiettivo then
			return SOLUZIONE;
		
		// espansione nodo
		foreach foglia in nodo.foglie()
			frontiera.push(foglia);
\end{lstlisting}
Il problema di questo tipo di ricerca \`e che non si tiene traccia dei nodi gi\`a visitati
quindi si potrebbe entrare in cicli da cui, non potendo pi\`u uscire, non riusciremmo n\'e
a trovare una soluzione n\'e riusciremmo a capire se questa esiste o meno.

\subsubsection{Nodi dell'albero di ricerca}
Un nodo \`e una struttura dati con quattro componenti:
\begin{itemize}
	\item Stato
	\item Riferimento al padre
	\item L'azione effettuata per generarlo
	\item Il costo del cammino dal nodo iniziale, indicato con $g(n)$
\end{itemize}

\subsubsection{La struttura dati della frontiera}
La frontiera \`e implementata come una lista che contiene i nodi in attesa di essere espansi.
In generale, tale lista ha a disposizione le due funzioni \verb|pop| e \verb|push| per rimuovere
e inserire nodi nella lista. Quello che cambia sono le possibili implementazione della lista
che daranno poi vita a diverse possibili strategie.

Nello specifico posso adottare 3 politiche principali:
\begin{itemize}
	\item FIFO, per implementare una coda da cui estraggo l'elemento in testa e inserisco
	      nuovi elementi in fondo (BF o Breadth-First).
	\item LIFO, per implementare una pila da cui estraggo l'elemento in testa e inserisco nuovi
	      elementi sempre in testa (DF o Depht-First).
	\item Coda con priorit\`a, in cui si estrae l'elemento a priorit\`a pi\`u alta e dopo
	      l'inserimento di nuovi elementi si riordina tutta la coda in base alle priorit\`a
	      (UC).
\end{itemize}

\subsubsection{Valutazione di una strategia di ricerca}
Ci sono quattro parametri fondamentali per valutare una strategia:
\begin{itemize}
	\item \textbf{Completezza}: se la soluzione esiste viene trovata.
	\item \textbf{Ottimalit\`a}: trova la soluzione migliore con costo minore.
	\item \textbf{Complessit\`a in tempo}: tempo richiesto per trovare la soluzione.
	\item \textbf{Complessit\`a in spazio}: memoria richiesta.
\end{itemize}

\section{Algoritmi di ricerca su grafo}
\subsection{Ricerca in ampiezza - BFS}
L'algoritmo BFS si basa sul visitare tutti i nodi adiacenti a quello corrente prima di
scendere ulteriormente in profondit\`a. In questo caso la frontiera \`e implementata
tramite una lista con politica FIFO. Si procede in questo modo:
\begin{enumerate}
	\item Inserisco il nodo iniziale nella frontiera.
	\item Estraggo un nodo dalla frontiera.
	\item Se la frontiera \`e vuota ho terminato la visita senza trovare il nodo soluzione.
	\item Si valuta che il nodo corrente sia o meno il nodo soluzione. Se lo \`e, termino
	      ritornando la soluzione.
	\item Inserisco tutti i nodi adiacenti a quello corrente (tranne il padre) nella
	      frontiera.
	\item Torno al punto 2.
\end{enumerate}

\subsubsection{Ricerca in ampiezza su albero}
In questo tipo di ricerca non si gestisce il problema di eventuali stati gi\`a esplorati.
\begin{lstlisting}[style=pseudo-style]
BFS_albero (problema)
	radice = problema.statoIniziale;
	frontiera.push(radice);
	while true
		if frontiera.isEmpty() then
			return FALLIMENTO;
		
		nodo = frontiera.pop();
		/* per ogni azione possibile da quel nodo genero un 
		nodo figlio */
		foreach azione in problema.Azioni(nodo.stato)
			figlio = Nodo(problema, nodo, azione);
			if problema.statoObbiettivo == figlio.stato then
				return SOLUZIONE;
			frontiera.push(figlio);
\end{lstlisting}

\subsubsection{Ricerca in ampiezza su grafo}
Con questo metodo si ovvia al problema della possibile espansione di nodi gi\`a esplorati
con una struttura dati aggiuntiva in cui, per l'appunto andiamo a inserire tutti i nodi
gi\`a esplorati. In sintesi guadagnamo in completezza ma perdiamo in utilizzo della memoria.
\begin{lstlisting}[style=pseudo-style]
BFS_grafo (problema)
radice = problema.statoIniziale;
frontiera.push(radice);
while true
	if frontiera.isEmpty() then
		return FALLIMENTO;
	
	nodo = frontiera.pop();
	esplorati.push(nodo);
	/* per ogni azione possibile da quel nodo genero un 
	nodo figlio */
	foreach azione in problema.Azioni(nodo.stato)
		figlio = Nodo(problema, nodo, azione);
		if figlio not in esplorati then
			if problema.statoObbiettivo == figlio.stato then
				return SOLUZIONE;
			frontiera.push(figlio);
\end{lstlisting}

\subsubsection{Analisi della complessit\`a in spazio e tempo}
Introduciamo tre valori utili all'analisi degli algoritmi.
\begin{itemize}
	\item \textbf b = fattore di ramificazione (numero massimo di successori)
	\item \textbf d = profondit\`a del nodo obbiettivo pi\`u vicino al nodo iniziale
	\item \textbf m = lunghezza massima dei cammini nello spazio degli stati
\end{itemize}