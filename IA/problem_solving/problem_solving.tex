\chapter{Algoritmi di ricerca}
Gli \textbf{algoritmi di ricerca} prendono in input un problema e restituiscono un
\textbf{cammino soluzione}, ovvero un cammino che porta dallo stato iniziale ad uno stato
obbiettivo.

Vengono valutati in base al \textbf{costo di ricerca} di una soluzione e anche
all'\textbf{efficienza} della soluzione trovata.

\section{Ricerca della soluzione}
Per trovare una soluzione si genera un \textbf{albero di ricerca} sovrapposto allo spazio
degli stati (generato da possibili azioni).

Ma come si genera l'albero di ricerca ?
\begin{enumerate}
	\item La radice dell'albero corrisponde allo stato iniziale.
	\item Ad ogni passo si sceglie una foglia dell'albero generato fino a quel momento.
	\item Le foglie costituiscono la \textbf{frontiera}.
	\item Ogni volta che visitiamo una foglia \textbf{espandiamo} tale nodo.
\end{enumerate}
Dobbiamo chiarire che un \emph{nodo} e uno \emph{stato} non sono la stessa cosa. Uno stato
\`e un'osservazione sul mondo del problema. Un nodo \`e una componente dell'albero di
ricerca e pu\`o capitare di avere pi\`u nodi con lo stesso stato.

\section{Ricerca ad albero}
Quello che facciamo in questo caso \`e una \textbf{visita} dello spazio degli stati finch\'e non
si giunge allo \textbf{stato obbiettivo} o finch\'e, dopo aver visitato tutti gli stati, ci
rendiamo conto di aver esplorato tutto lo spazio degli stati (o almeno quello esplorabile
partendo dallo stato fornito in partenza).

Per fare la visita avremo bisogno di un buffer che chiameremo \textbf{frontiera}, dove metteremo
gli stati adiacenti a quello corrente che intendiamo visitare.
\newpage
L'algoritmo procede in questo modo:
\begin{enumerate}
	\item Si sceglie uno stato iniziale e si mette nella frontiera.
	\item Si entra in un ciclo da cui si pu\`o uscire solo in due modi:
	      \begin{itemize}
		      \item Si trova la soluzione.
		      \item Si esaurisce tutto lo spazio degli stati senza trovare la soluzione (quindi
		            non esiste).
	      \end{itemize}
	\item Verifichiamo che la frontiera non sia vuota, se lo \`e abbiamo esaurito tutti gli
	      stati visitabili e quindi non c'\`e una soluzione e l'algoritmo termina con
	      fallimento.
	\item Si estrae un nodo dalla frontiera e controlliamo se lo stato \`e equivalente allo
	      stato obbiettivo, se s\`i, l'algoritmo termina ritornando la soluzione.
	\item Si inseriscono tutti i nodi figlio del nodo corrente nella frontiera.
	\item Si torna al punto 2.
\end{enumerate}
\begin{lstlisting}[style=pseudo-style]
Ricerca_albero (problema)
	// inizializzazione frontiera con lo stato iniziale
	radice = problema.statoIniziale;
	frontiera.push(radice);
	while true
		// non esiste una soluzione
		if frontiera.isEmpty() then
			return FALLIMENTO;
		
		// prendo un nodo dalla frontiera
		nodo = frontiera.pop();
		
		// nel caso in cui si trovi il nodo obbiettivo
		if nodo.stato == problema.statoObbiettivo then
			return SOLUZIONE;
		
		// espansione nodo
		foreach foglia in nodo.foglie()
			frontiera.push(foglia);
\end{lstlisting}
Il problema di questo tipo di ricerca \`e che non si tiene traccia dei nodi gi\`a visitati
quindi si potrebbe entrare in cicli da cui, non potendo pi\`u uscire, non riusciremmo n\'e
a trovare una soluzione n\'e riusciremmo a capire se questa esiste o meno.

\subsection{Nodi dell'albero di ricerca}
Un nodo \`e una struttura dati con quattro componenti:
\begin{itemize}
	\item Stato
	\item Riferimento al padre
	\item L'azione effettuata per generarlo
	\item Il costo del cammino dal nodo iniziale, indicato con $g(n)$
\end{itemize}

\subsection{La struttura dati della frontiera}
La frontiera \`e implementata come una lista che contiene i nodi in attesa di essere espansi.
In generale, tale lista ha a disposizione le due funzioni \verb|pop| e \verb|push| per rimuovere
e inserire nodi nella lista. Quello che cambia sono le possibili implementazione della lista
che daranno poi vita a diverse possibili strategie.

Nello specifico posso adottare 3 politiche principali:
\begin{itemize}
	\item FIFO, per implementare una coda da cui estraggo l'elemento in testa e inserisco
	      nuovi elementi in fondo (BF o Breadth-First).
	\item LIFO, per implementare una pila da cui estraggo l'elemento in testa e inserisco nuovi
	      elementi sempre in testa (DF o Depht-First).
	\item Coda con priorit\`a, in cui si estrae l'elemento a priorit\`a pi\`u alta e dopo
	      l'inserimento di nuovi elementi si riordina tutta la coda in base alle priorit\`a
	      (UC).
\end{itemize}

\subsection{Valutazione di una strategia di ricerca}
Ci sono quattro parametri fondamentali per valutare una strategia:
\begin{itemize}
	\item \textbf{Completezza}: se la soluzione esiste viene trovata.
	\item \textbf{Ottimalit\`a}: trova la soluzione migliore con costo minore.
	\item \textbf{Complessit\`a in tempo}: tempo richiesto per trovare la soluzione.
	\item \textbf{Complessit\`a in spazio}: memoria richiesta.
\end{itemize}

\section{Algoritmi di ricerca su grafo}
\subsection{Ricerca in ampiezza - BFS}
L'algoritmo BFS si basa sul visitare tutti i nodi adiacenti a quello corrente prima di
scendere ulteriormente in profondit\`a. In questo caso la frontiera \`e implementata
tramite una lista con politica FIFO. Si procede in questo modo:
\begin{enumerate}
	\item Inserisco il nodo iniziale nella frontiera.
	\item Estraggo un nodo dalla frontiera.
	\item Se la frontiera \`e vuota ho terminato la visita senza trovare il nodo soluzione.
	\item Si valuta che il nodo corrente sia o meno il nodo soluzione. Se lo \`e, termino
	      ritornando la soluzione.
	\item Inserisco tutti i nodi adiacenti a quello corrente (tranne il padre) nella
	      frontiera.
	\item Torno al punto 2.
\end{enumerate}

\subsubsection{Ricerca in ampiezza su albero}
In questo tipo di ricerca non si gestisce il problema di eventuali stati gi\`a esplorati.
Cos\`i facendo andiamo incontro alla possibilit\`a di incontrare cicli da cui poi non
riusciremmo pi\`u a uscire.
\begin{lstlisting}[style=pseudo-style]
BFS_albero (problema)
	radice = problema.statoIniziale;
	frontiera.push(radice);
	risultato = null;
	while risultato == null
		if frontiera.isEmpty() then
			risultato = FALLIMENTO;
		else
			nodo = frontiera.pop();
			/* per ogni azione possibile da quel nodo genero un 
			nodo figlio */
			foreach azione in problema.Azioni(nodo.stato)
				figlio = Nodo(problema, nodo, azione);
				if problema.statoObbiettivo == figlio.stato then
					risultato = SOLUZIONE;
				else
					frontiera.push(figlio);
	return risultato;
\end{lstlisting}

\subsubsection{Ricerca in ampiezza su grafo}
Con questo metodo si ovvia al problema della possibile espansione di nodi gi\`a esplorati
con una struttura dati aggiuntiva in cui, per l'appunto andiamo a inserire tutti i nodi
gi\`a esplorati. In sintesi guadagnamo in completezza ma perdiamo in utilizzo della memoria.
\begin{lstlisting}[style=pseudo-style]
BFS_grafo (problema)
	radice = problema.statoIniziale;
	frontiera.push(radice);
	esplorati = [];
	risultato = null;
	while risultato == null
		if frontiera.isEmpty() then
			risultato = FALLIMENTO;
		else
			nodo = frontiera.pop();
			esplorati.push(nodo.stato);
			/* per ogni azione possibile da quel nodo genero un 
			nodo figlio */
			foreach azione in problema.Azioni(nodo.stato)
				figlio = Nodo(problema, nodo, azione);
				if figlio.stato not in esplorati and figlio not in frontiera then
					if problema.statoObbiettivo == figlio.stato then
						risultato = SOLUZIONE;
					else
						frontiera.push(figlio);
	return risultato;
\end{lstlisting}

\subsubsection{Analisi BFS}
Introduciamo tre valori utili all'analisi degli algoritmi.
\begin{itemize}
	\item \textbf b = fattore di ramificazione (numero massimo di successori)
	\item \textbf d = profondit\`a del nodo obbiettivo pi\`u vicino al nodo iniziale
	\item \textbf m = lunghezza massima dei cammini nello spazio degli stati
\end{itemize}
Per quanto riguarda la ricerca in ampiezza (BFS) possiamo dire che
\begin{itemize}
	\item \`E completa.
	\item \`E ottimale se gli operatori hanno tutti lo stesso costo $k$, cio\`e
	      \[ g(n) = k \cdot depth(n) \]
	      dove $g(n)$ \`e il costo del cammino per arrivare a $n$.
	\item La complessit\`a in tempo \`e rappresentata da
	      \[ T(b, d) = b + b^2 + \cdots + b^d \rightarrow O(b^d) \]
	\item La complessit\`a in sapzio \`e $O(b^d)$.
\end{itemize}

\subsection{Ricerca in profondit\`a - DFS}
L'algoritmo di ricerca DFS si basa su una visita in profondit\`a, ovvero, una volta visitato
un figlio del nodo, si procede alla visita del figlio del figlio. Si procede cos\`i finch\'e
non si raggiunge il nodo obbiettivo oppure finch\'e non si raggiunge un nodo senza figli.
L'ordine di visita \`e dato  tramite una lista con politica LIFO.
\begin{enumerate}
	\item Visito il nodo corrente.
	\item Se \`e il nodo contenente lo stato soluzione termino ritornando la soluzione.
	\item Visito il primo figlio del nodo corrente.
	\item Torno al punto 1.
\end{enumerate}

\subsubsection{Ricerca in profondit\`a su albero (versione ricorsiva)}
Come prima non viene gestito il problema dei nodi gi\`a esplorati e in questo caso adotta un
approccio di tipo ricorsivo, che fornisce un vantaggio in spazio visto che non dobbiamo
salvarci in memoria gli stati ma vengono tenuti in uno stack in caso di fallimento.
\begin{lstlisting}[style=pseudo-style]
DFS_albero_ricorsivo (problema, nodo)
	if nodo.stato == problema.statoObbiettivo then
		return SOLUZIONE(nodo);
	
	foreach azione in problema.Azioni(nodo.stato)
		figlio = Nodo(problema, nodo, azione);
		risultato = DFS_albero_ricorsivo(problema, figlio);
		if risultato != fallimento then
			return risultato;
		return fallimento;
\end{lstlisting}

\subsubsection{Ricerca in profondit\`a su grafo (versione iterativa)}
Con questo metodo non abbiamo pi\`u il problema della possibile visita di nodi gi\`a visitati
ma perdiamo il vantaggio in memoria del metodo precedente.
\begin{lstlisting}[style=pseudo-style]
DFS_grafo (problema)
	radice = statoIniziale;
	frontiera.push(radice);
	esplorati = [];
	risultato = null;
	while risultato == null
		if frontiera.isEmpty() then
			risultato = FALLIMENTO;
		else
			nodo = frontiera.pop();
			esplorati.push(nodo.stato);
			foreach azione in problema.Azioni(nodo.stato)
				figlio = Nodo(problema, nodo, azione);
				if figlio.stato not in esplorati and figlio not in frontiera then
					if problema.statoObbiettivo == figlio.stato then
						risultato = SOLUZIONE;
					else
						frontiera.push(figlio);
	return risultato;	
\end{lstlisting}
Come possiamo notare, l'algoritmo \`e identico a quello ricerca BFS su grafo. Ci\`o che cambia
e che ci permette di effettuare una visita in profondit\`a \`e il fatto che la lista \`e
implementata con una politica LIFO.

\subsubsection{Analisi DFS}
Per questo algoritmo dobbiamo differenziare tra la variante su albero e su grafo. Sulla prima
possiamo dire che:
\begin{itemize}
	\item Non \`e completa.
	\item Non \`e ottimale.
	\item La complessit\`a in tempo \`e $O(b^m)$ dove $m$ \`e la lunghezza massima dei cammini
	      nello spazio degli stati (pu\`o essere maggiore di $O(b^d)$).
	\item La complessit\`a in spazio \`e $O(bm)$.
\end{itemize}
Per la versione su grafo possiamo dire che:
\begin{itemize}
	\item \`E completa in spazi di stati finiti. Ma non completa per spazi infiniti.
	\item Non \`e ottimale.
	\item La complessit\`a in tempo \`e $O(b^m)$.
	\item La complessit\`a in spazio \`e $O(b^m)$.
\end{itemize}

\newpage
\subsection{Ricerca in profondit\`a limitata - DLS}
Questo algoritmo \`e una variante della DFS in cui si da un limite di profondit\`a oltre
il quale non si deve scendere.

\subsubsection{Analisi DLS}
Leggermente migliore della DFS, possiamo affermare che:
\begin{itemize}
	\item \`E completa per problemi in cui si conosce un limite superiore per la profondit\`a
	      della soluzione ($d < l$ dove $l$ \`e il limite di profondit\`a).
	\item Non \`e ottimale.
	\item La complessit\`a in tempo \`e $O(b^l)$.
	\item La complessit\`a in spazio \`e $O(bl)$ (per la versione su albero).
\end{itemize}

\section{Ricerca bidirezionale}
Per la costruzione di nuove strategie possiamo porci il problema della direzione verso cui
effettuare la ricerca.
Da qui possono nascere due possibili approcci:
\begin{itemize}
	\item Ricerca \textbf{in avanti} (guidata dai dati), in cui si esplora lo spazio di
	      ricerca dallo stato iniziale allo stato obbiettivo.
	\item Ricerca \textbf{all'indietro} (guidata dall'obbiettivo), in cui si esplora lo
	      spazio di ricerca partendo da uno stato goal e riconducendosi ad un sotto-goal
	      fino a trovare uno stato iniziale.
\end{itemize}
In generale conviene procedere nella direzione in cui il \emph{fattore di diramazione}
\`e minore.
Pi\`u nello specifico, si preferisce la ricerca
\begin{itemize}
	\item in avanti quando gli obbiettivi possibili sono molti e abbiamo una serie di dati
	      da cui partire.
	\item all'indietro quando l'obbiettivo \`e chiaramento definito o si possono formulare
	      una serie limitata di passi di ipotesi, oppure quando i dati del problema non
	      sono noti e la loro acquisizione pu\`o essere guidata dall'obbiettivo.
\end{itemize}
Nella \textbf{ricerca bidirezionale} si procede nelle due direzioni fino ad incontrarsi.

\subsubsection{Analisi ricerca bidirezionale}
Su questo tipo di ricerca possiamo dire che:
\begin{itemize}
	\item La complessit\`a in tempo \`e $O(b^{d/2})$ assumendo test di intersezione in
	      tempo costante.
	\item La complessit\`a in spazio \`e $O(b^{d/2})$.
\end{itemize}

\section{Ricerca di costo uniforme UC}
\`E una generalizzazione della ricerca in ampiezza: si sceglie il nodo di costo minore sulla
frontiera, si espende sui nodi adiacenti di uguale costo invece che sui nodi adiacenti di
uguale profondit\`a.
La frontiera \`e implementata da una lista ordinata per costo di cammino crescente (in cima
ci vanno i nodi di costo minore).
\subsection{Ricerca di costo uniforme su albero}
Vediamo un'idea di algoritmo di questo tipo di ricerca:
\begin{lstlisting}[style=pseudo-style]
UC_albero (problema)
	radice = statoIniziale;
	frontiera.push(radice);

	while true
		if frontiera.isEmpty() then
			return FALLIMENTO;
		
		nodo = frontiera.pop();
		if nodo.stato == problema.statoObbiettivo then
			return SOLUZIONE;
		
		foreach azione in problema.Azioni(nodo.stato)
			figlio = Nodo(problema, nodo, azione);
			frontiera.push(figlio);
\end{lstlisting}

\subsection{Ricerca di costo uniforme su grafo}
Come per i precedenti ora teniamo conto degli stati gi\`a esplorati.
\begin{lstlisting}[style=pseudo-style]
UC_grafo (problema)
	radice = statoIniziale;
	frontiera.push(radice);
	esplorati = [];

	while true
		if frontiera.isEmpty() then
			return FALLIMENTO;
		
		nodo = frontiera.pop();
		esplorati.push(nodo.stato);
		
		foreach azione in problema.Azioni(nodo.stato)
			figlio = Nodo(problema, nodo, azione);
			if figlio.stato not in esplorati and figlio not in frontiera then
				if nodo.stato == problema.statoObbiettivo then
					return SOLUZIONE;
				frontiera.push(figlio);
\end{lstlisting}

\subsubsection{Analisi UC}
Su questo tipo di algoritmo possiamo dire che:
\begin{itemize}
	\item \`E completo e ottimo a patto che il costo degli archi sia maggiore di
	      $\epsilon > 0$
	\item Assunto $C$ come costo della soluzione ottima $\lfloor C/\epsilon \rfloor$ \`e
	      il numero di mosse nel caso peggiore.
	\item Le complessit\`a in tempo e spazio sono $O(b^{1+\lfloor C/\epsilon \rfloor})$.
\end{itemize}