\chapter{Algoritmi di ricerca}
Gli \textbf{algoritmi di ricerca} prendono in input un problema e restituiscono un
\textbf{cammino soluzione}, ovvero un cammino che porta dallo stato iniziale ad uno stato
obbiettivo.

Vengono valutati in base al \textbf{costo di ricerca} di una soluzione e anche
all'\textbf{efficienza} della soluzione trovata.

\section{Ricerca della soluzione}
Per trovare una soluzione si genera un \textbf{albero di ricerca} sovrapposto allo spazio
degli stati (generato da possibili azioni).

Ma come si genera l'albero di ricerca ?
\begin{enumerate}
	\item La radice dell'albero corrisponde allo stato iniziale.
	\item Ad ogni passo si sceglie un nodo figlio del nodo corrente.
	\item I figli del nodo corrente vengono inseriti nella \textbf{frontiera}, struttura
	      dati dove vengono messi i nodi in attesa di essere visitati (approfondimento
	      pi\`u avanti).
	\item Estraiamo i nodi uno ad uno dalla frontiera per visitarli ripetendo il solito
	      procedimento.
	\item Ogni volta che visitiamo un nodo lo stiamo \textbf{espandendo}.
\end{enumerate}
Dobbiamo chiarire che un \emph{nodo} e uno \emph{stato} non sono la stessa cosa. Uno stato
\`e un'osservazione sul mondo del problema. Un nodo \`e una componente dell'albero di
ricerca e pu\`o capitare di avere pi\`u nodi con lo stesso stato.

\subsection{Nodi dell'albero di ricerca}
Un nodo \`e una struttura dati con quattro componenti:
\begin{itemize}
	\item Stato
	\item Riferimento al padre
	\item L'azione effettuata per generarlo
	\item Il costo del cammino dal nodo iniziale, indicato con $g(n)$
\end{itemize}

\subsection{La struttura dati della frontiera}
La \textbf{frontiera} \`e implementata come una lista che contiene i nodi in attesa di essere
espansi (visitati). In generale, tale lista ha a disposizione le due funzioni \verb|pop| e
\verb|push| per rimuovere e inserire nodi nella lista. Quello che cambia sono le possibili
implementazioni della lista che daranno poi vita a diverse possibili strategie.

Nello specifico posso adottare 3 politiche principali:
\begin{itemize}
	\item FIFO, per implementare una coda da cui estraggo l'elemento in testa e inserisco
	      nuovi elementi in fondo (BF o Breadth-First).
	\item LIFO, per implementare una pila da cui estraggo l'elemento in testa e inserisco nuovi
	      elementi sempre in testa (DF o Depht-First).
	\item Coda con priorit\`a, in cui si estrae l'elemento a priorit\`a pi\`u alta e dopo
	      l'inserimento di nuovi elementi si riordina tutta la coda in base alle priorit\`a
	      (UC).
\end{itemize}

\subsection{Valutazione di una strategia di ricerca}
Ci sono quattro parametri fondamentali per valutare una strategia:
\begin{itemize}
	\item \textbf{Completezza}: se la soluzione esiste viene trovata.
	\item \textbf{Ottimalit\`a}: trova la soluzione migliore con costo minore.
	\item \textbf{Complessit\`a in tempo}: tempo richiesto per trovare la soluzione.
	\item \textbf{Complessit\`a in spazio}: memoria richiesta.
\end{itemize}
Introduciamo inoltre tre valori utili all'analisi degli algoritmi di ricerca che generano
un albero di ricerca.
\begin{itemize}
	\item \textbf b = fattore di ramificazione (numero massimo di successori)
	\item \textbf d = profondit\`a del nodo obbiettivo pi\`u vicino al nodo iniziale
	\item \textbf m = lunghezza massima dei cammini nello spazio degli stati
\end{itemize}

\section{Ricerca su albero}
L'algoritmo in questione ha la caratteristica di essere efficiente in memoria, tuttavia
non tiene traccia dei nodi gi\`a visitati. Questo potrebbe portare la ricerca a compiere
cammini ciclici da cui poi non si riuscirebbe pi\`u ad uscire.

I passi principali dell'algoritmo sono questi:
\begin{enumerate}
	\item Si sceglie uno stato iniziale e si mette nella frontiera.
	\item Verifichiamo che la frontiera non sia vuota, se lo \`e abbiamo esaurito tutti gli
	      stati visitabili e quindi non c'\`e una soluzione e l'algoritmo termina con
	      fallimento.
	\item Si estrae un nodo dalla frontiera e controlliamo se lo stato \`e equivalente allo
	      stato obbiettivo, se s\`i, l'algoritmo termina ritornando la soluzione.
	\item Si inseriscono tutti i nodi figlio del nodo corrente nella frontiera.
	\item Si torna al punto 2.
\end{enumerate}
\begin{lstlisting}[style=pseudo-style]
ricerca_albero (problema)
	// inizializzazione frontiera con lo stato iniziale
	radice = problema.statoIniziale;
	frontiera.push(radice);
	risultato = null;
	while risultato == null
		// non esiste una soluzione
		if frontiera.isEmpty() then
			risultato = FALLIMENTO;
		else
			// prendo un nodo dalla frontiera
			nodo = frontiera.pop();
		
			// nel caso in cui si trovi il nodo obbiettivo
			if nodo.stato == problema.statoObbiettivo then
				risultato = SOLUZIONE;
			else
				// espansione nodo
				foreach azione in problema.Azioni(nodo.stato)
					figlio = Nodo(problema, nodo, azione);
					frontiera.push(figlio);
	return risultato;
\end{lstlisting}

\section{Ricerca su grafo}
Questo tipo di ricerca si differenzia da quella su albero perch\'e stavolta si tiene traccia
dei nodi gi\`a visitati e dunque non si rischia di entrare in cicli. L'occupazione di memoria
potrebbe essere tuttavia notevole.

L'algoritmo non \`e molto diverso dal precendente e segue i seguenti passi:
\begin{enumerate}
	\item Si sceglie uno stato iniziale e si mette nella frontiera.
	\item Verifichiamo che la frontiera non sia vuota, se lo \`e abbiamo esaurito tutti gli
	      stati visitabili e quindi non c'\`e una soluzione e l'algoritmo termina con
	      fallimento.
	\item Si estrae un nodo dalla frontiera, se contiene lo stato obbiettivo l'algoritmo
	      termina ritornando la soluzione.
	\item Inserisco il nodo nella lista dei nodi esplorati.
	\item Espando il nodo e inserisco i nodi figlio nella frontiera solo se non ci sono gi\`a
	      e se non sono nemmeno nella lista dei nodi esplorati.
	\item Si torna al punto 2.
\end{enumerate}

\section{Ricerca in ampiezza - BFS}
L'algoritmo BFS compie una visita in ampiezza, ovvero, visita prima tutti i nodi che stanno
alla stessa profondit\`a dell'albero di ricerca e poi scende pi\`u in profondit\`a.
Questo ci garantisce l'ottimo della soluzione trovata (se esiste). Per creare questo
tipo di algoritmo baster\`a implementare la frontiera come una lista con politica FIFO
(coda) e procedere come descritto sopra.

\subsection{Analisi BFS}
Per quanto riguarda la ricerca in ampiezza (BFS) possiamo dire che
\begin{itemize}
	\item \`E completa.
	\item \`E ottimale se gli operatori hanno tutti lo stesso costo $k$, cio\`e
	      \[ g(n) = k \cdot depth(n) \]
	      dove $g(n)$ \`e il costo del cammino per arrivare a $n$.
	\item La complessit\`a in tempo \`e rappresentata da
	      \[ T(b, d) = b + b^2 + \cdots + b^d \rightarrow O(b^d) \]
	\item La complessit\`a in sapzio \`e $O(b^d)$.
\end{itemize}

\section{Ricerca in profondit\`a - DFS}
L'algoritmo di ricerca DFS effettua una visita in profondit\`a, ovvero, continua a scendere
in profondit\`a finch\'e non trova un nodo senza figli e quindi torna indietro fino alla
prima diramazione da cui \`e possibile ricominciare a scendere. Ovviamente se si trova la
soluzione ci si ferma prima. L'algoritmo rimane il solito illustrato in precendeza, sia per
la versione su albero che per la versione su grafo. Ci\`o che rende possibile questa
modalit\`a di visita \`e l'implementazione della frontiera come una lista con politica LIFO
(pila).

\subsection{Ricerca in profondit\`a su albero (versione ricorsiva)}
Come prima non viene gestito il problema dei nodi gi\`a esplorati e in questo caso adotta un
approccio di tipo ricorsivo, che fornisce un vantaggio in spazio visto che non dobbiamo
salvarci in memoria gli stati ma vengono tenuti in uno stack in caso di fallimento.
\begin{lstlisting}[style=pseudo-style]
DFS_albero_ricorsivo (problema, nodo)
	if nodo.stato == problema.statoObbiettivo then
		return SOLUZIONE(nodo);
	
	foreach azione in problema.Azioni(nodo.stato)
		figlio = Nodo(problema, nodo, azione);
		risultato = DFS_albero_ricorsivo(problema, figlio);
		if risultato != fallimento then
			return risultato;
		return fallimento;
\end{lstlisting}

\subsection{Analisi DFS}
Per questo algoritmo dobbiamo differenziare tra la variante su albero e su grafo. Sulla prima
possiamo dire che:
\begin{itemize}
	\item Non \`e completa.
	\item Non \`e ottimale.
	\item La complessit\`a in tempo \`e $O(b^m)$ dove $m$ \`e la lunghezza massima dei cammini
	      nello spazio degli stati (pu\`o essere maggiore di $O(b^d)$).
	\item La complessit\`a in spazio \`e $O(bm)$.
\end{itemize}
Per la versione su grafo possiamo dire che:
\begin{itemize}
	\item \`E completa in spazi di stati finiti. Ma non completa per spazi infiniti.
	\item Non \`e ottimale.
	\item La complessit\`a in tempo \`e $O(b^m)$.
	\item La complessit\`a in spazio \`e $O(b^m)$.
\end{itemize}

\section{Ricerca in profondit\`a limitata - DLS}
Questo algoritmo \`e una variante della DFS in cui si da un limite di profondit\`a oltre
il quale non si deve scendere.

\subsection{Analisi DLS}
Leggermente migliore della DFS, possiamo affermare che:
\begin{itemize}
	\item \`E completa per problemi in cui si conosce un limite superiore per la profondit\`a
	      della soluzione ($d < l$ dove $l$ \`e il limite di profondit\`a).
	\item Non \`e ottimale.
	\item La complessit\`a in tempo \`e $O(b^l)$.
	\item La complessit\`a in spazio \`e $O(bl)$ (per la versione su albero).
\end{itemize}

\section{Ricerca bidirezionale}
Per la costruzione di nuove strategie possiamo porci il problema della direzione verso cui
effettuare la ricerca.
Da qui possono nascere due possibili approcci:
\begin{itemize}
	\item Ricerca \textbf{in avanti} (guidata dai dati), in cui si esplora lo spazio di
	      ricerca dallo stato iniziale allo stato obbiettivo.
	\item Ricerca \textbf{all'indietro} (guidata dall'obbiettivo), in cui si esplora lo
	      spazio di ricerca partendo da uno stato goal e riconducendosi ad un sotto-goal
	      fino a trovare uno stato iniziale.
\end{itemize}
In generale conviene procedere nella direzione in cui il \emph{fattore di diramazione}
\`e minore.
Pi\`u nello specifico, si preferisce la ricerca
\begin{itemize}
	\item in avanti quando gli obbiettivi possibili sono molti e abbiamo una serie di dati
	      da cui partire.
	\item all'indietro quando l'obbiettivo \`e chiaramento definito o si possono formulare
	      una serie limitata di passi di ipotesi, oppure quando i dati del problema non
	      sono noti e la loro acquisizione pu\`o essere guidata dall'obbiettivo.
\end{itemize}
Nella \textbf{ricerca bidirezionale} si procede nelle due direzioni fino ad incontrarsi.

\subsection{Analisi ricerca bidirezionale}
Su questo tipo di ricerca possiamo dire che:
\begin{itemize}
	\item La complessit\`a in tempo \`e $O(b^{d/2})$ assumendo test di intersezione in
	      tempo costante.
	\item La complessit\`a in spazio \`e $O(b^{d/2})$.
\end{itemize}

\section{Ricerca di costo uniforme UC}
\`E una generalizzazione della ricerca in ampiezza: si sceglie il nodo di costo minore sulla
frontiera e si espande sui nodi adiacenti di uguale costo invece che sui nodi adiacenti di
uguale profondit\`a.
La frontiera \`e implementata da una lista ordinata per costo di cammino crescente (in cima
ci vanno i nodi di costo minore).

\subsection{Analisi UC}
Su questo tipo di algoritmo possiamo dire che:
\begin{itemize}
	\item \`E completo e ottimale a patto che il costo degli archi sia maggiore di
	      $\epsilon > 0$
	\item Assunto $C$ come costo della soluzione ottima $\lfloor C/\epsilon \rfloor$ \`e
	      il numero di mosse nel caso peggiore.
	\item Le complessit\`a in tempo e spazio sono $O(b^{1+\lfloor C/\epsilon \rfloor})$.
\end{itemize}