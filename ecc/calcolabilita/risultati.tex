\section{Risultati classici}
Arriviamo finalmente al sodo di questa prima parte del corso in
cui abbiamo definito formalismi su formalismi senza capire bene
come, quando o perché applicarli.

Introdurremo quindi alcuni risultati della teoria della
calcolabilità che ci permetteranno di caratterizzare la classe
delle funzioni calcolabili, mediante alcuni teoremi di
\emph{"chiusura"}.

Prima di iniziare chiariamo che, grazie alla
\hyperref[th: church-turing]{tesi di Church-Turing}, possiamo
chiamare \emph{calcolabili} tutte le funzioni che rispettano
le cinque condizioni intuitive poste agli algoritmi definite
nell'\hyperref[sec: algoritmo]{idea intuitiva di algoritmo},
indipendentemente dal loro formalismo.

\begin{theorem} \label{th: n calc}
	Le funzioni calcolabili sono $\#(\N)$, così come le funzioni
	calcolabili totali.
	\begin{proof}
		Costruiamo $\#(\N)$ MdT $M_i$ che svuotano il nastro
		dell'input e scrivono una stringa di tante $|$ quanto
		vale $i$ e si arrestano.
	\end{proof}
\end{theorem}

Che non siano più di $\#(\N)$ segue dal fatto che le $MdT$
si possono enumerare, come mostrato in precedenza
(\ref{ssec: enum MdT}).

\begin{theorem}
	Esistono funzioni non calcolabili.
	\begin{proof}
		Con una costruzione analoga a quella di Cantor, in cui
		la classe dei sottoinsiemi di $\N$ non è numerabile,
		si vede che
		\[
			\# \left( \{ f \mid f : \N \to \N \} \right) =
			2^{\#(\N)}
		\]
		segue dal teorema \ref{th: n calc} che esistono dunque
		delle funzioni non calcolabili.
	\end{proof}
\end{theorem}

Come abbiamo già visto, è possibile enumerare le MdT, associando
loro un indice. Analogamente è possibile enumerare le funzioni
ricorsive primitive e non è difficile pensare ad un'estensione
per l'enumerazione di funzioni $\mu$-ricorsive.

I due metodi hanno in comune il fatto che si basano solamente
sui simboli usati per definire gli algoritmi. Infatti, sotto
ragionevoli ipotesi, per i nostri scopi non c'è differenza tra
un metodo di enumerazione e l'altro, purché sia \emph{effettivo}.

Data un'enumerazione effettiva, indicheremo con $\varphi_i$ la
funzione parziale che la macchina, o meglio l'algoritmo, $M_i$
calcola e chiameremo $i$ \emph{indice}. L'indice è riferito
alla macchina e non alla funzione, infatti potrebbe darsi che
per $i \neq j$, valga $\varphi_i = \varphi_j$, ma sicuramente
vale $M_i \neq M_j$.

\begin{theorem}[Padding lemma] \label{th: padding lemma}
	Ogni funzione calcolabile $\varphi_x$ ha $\# (N)$ indici.
	Vale inoltre che $\forall x$ si può costruire, mediante una
	funzione ricorsiva primitiva, un insieme infinito $A_x$ di
	indici tale che $\forall y \in A_x$, vale
	\[ \varphi_y = \varphi_x \]
	\begin{proof}
		Per ogni macchina $M_x$, se $Q = \{ q_0, \dots, q_k \}$
		è l'insieme degli stati possibili di $M_x$. Aggiungendo
		lo stato $q_{k+1}$ e la quintupla
		\[ (q_{k+1}, \#, q_{k+1}, \#, -) \]
		a tale macchina, si ottiene la macchina $M_{x_1}$ con
		$x_1 \in A_x$. Possiamo continuare all'infinito
		aggiungendo stati e quintuple che di fatto sono inutili,
		o per meglio dire non vengono mai raggiunti dalla
		macchina e non cambiano quindi cosa essa calcola.
	\end{proof}
\end{theorem}

Questo teorema ci dice che esistono infiniti algoritmi
numerabili che calcolano la stessa funzione e che alcuni di
loro sono ottenibili \emph{facilmente} da un algoritmo dato.

\begin{theorem}[Forma normale] \label{th: fn}
	Esistono un predicato $T(i, x, y)$ e una funzione $U(y)$
	calcolabili totali tali che $\forall i,x$ vale
	\[ \varphi_i(x) = U(\mu y . T (i, x, y)) \]
	Inoltre $T$ e $U$ sono ricorsive primitive.
	\begin{proof}
		Definiamo $T(i,x,y)$, detto comunemente
		\textbf{predicato di Kleene}, vero se e solo se $y$ è
		la codifica di una computazione terminante di $M_i$
		con dato iniziale $x$. Per calcolare $T$ dato $i$,
		recuperiamo $M_i$ dalla lista e cominciamo a scandire
		i valori $y$. Decodifichiamo ognuno di essi e, avendo
		come ingresso $x$ controlliamo se il risultato è una
		computazione terminante della forma
		\[ M_i(x) = c_0, c_1, \dots, c_n \]
		Se lo è, allora $c_n = (h, \start z \underline{\#})$ e
		definiamo $U$ in modo che $U(y) = z$.

		Il procedimento è effettivo e quindi $T$ e $U$ sono
		calcolabili per la tesi di Church-Turing, inoltre tale
		procedimento termina sempre e dunque $T$ e $U$ sono
		totali. Abbiamo inoltre che $T$ e $U$ sono ricorsive
		primitive perché sai le codifiche usate, che i controlli
		effettuati lo sono.
	\end{proof}
\end{theorem}

Questo teorema ci dice che tra tutti gli algoritmi che calcolano
la stessa funzione, uno di questi ha una forma privilegiata,
ossia quella \emph{normale} e di conseguenza ogni funzione ha
una forma normale.

Proviamo ad uscire un minimo dal formalismo del teorema stesso 
procedendo per step. Iniziamo dal predicato di Kleene: esso è 
una funzione che semplicemente ritorna vero se $y$ è la codifica
(in questo caso possiamo considerare l'enumerazione di G\"odel)
di una computazione terminante della macchina $M_i$ che prende 
in input $x$.

Come abbiamo già visto una computazione, vista come una sequenza 
finita di passi è anch'essa enumerabile ed è quindi possibile
immaginare che valga 
\[ M_i (x) = c_0, c_1, \dots, c_n \]
dove i vari $c_i$ sono le varie configurazioni raggiunte dalla 
macchina durante la computazione. Se la computazione termina 
allora abbiamo che $T$ ritorna vero e che sicuramente l'ultima 
configurazione, ossia $c_n$ è equivalente a 
\[ c_n = (h, \start z \underline{\#}) \]
poiché siamo sicuramente giunti nello stato speciale $h$, 

\begin{theorem}
	Le funzioni T-calcolabili sono $\mu$-ricorsive.
\end{theorem}

Questo corollario è una diretta conseguenza del teorema di
forma normale. Possiamo quindi dire che ogni funzione calcolata
da una MdT ammette una definizione $\mu$-ricorsiva.

\begin{lemma}
	Le funzioni $\mu$-calcolabili sono T-calcolabili.
\end{lemma}

\begin{theorem}
	Una funzione è T-calcolabili se e solo se è
	$\mu$-calcolabile.
\end{theorem}
