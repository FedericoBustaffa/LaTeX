\section{Risultati classici}
Arriviamo finalmente al sodo di questa prima parte del corso in
cui abbiamo definito formalismi su formalismi senza capire bene
come, quando o perché applicarli.

Introdurremo quindi alcuni risultati della teoria della
calcolabilità che ci permetteranno di caratterizzare la classe
delle funzioni calcolabili, mediante alcuni teoremi di
\emph{"chiusura"}.

Prima di iniziare chiariamo che, grazie alla
\hyperref[th: church-turing]{tesi di Church-Turing}, possiamo
chiamare \emph{calcolabili} tutte le funzioni che rispettano
le cinque condizioni intuitive poste agli algoritmi definite
nell'\hyperref[sec: algoritmo]{idea intuitiva di algoritmo},
indipendentemente dal loro formalismo.

\subsection{Cardinalità delle funzioni calcolabili}
Iniziamo con un paio di teoremi che dovrebbe darci l'idea del
numero di funzioni calcolabili e non, dimostrando anche
l'esistenza di queste ultime.

\begin{theorem} \label{th: n calc}
	Le funzioni calcolabili sono $\#(\N)$, così come le funzioni
	calcolabili totali.
	\begin{proof}
		Costruiamo $\#(\N)$ MdT $M_i$ che svuotano il nastro
		dell'input e scrivono una stringa di tante $|$ quanto
		vale $i$ e si arrestano.
	\end{proof}
\end{theorem}

Che non siano più di $\#(\N)$ segue dal fatto che le $MdT$
si possono enumerare, come mostrato in precedenza
(\ref{ssec: enum MdT}).

\begin{theorem} \label{th: exists non calc}
	Esistono funzioni non calcolabili.
	\begin{proof}
		Con una costruzione analoga a quella di Cantor, in cui
		la classe dei sottoinsiemi di $\N$ non è numerabile,
		si vede che
		\[
			\# \left( \{ f \mid f : \N \to \N \} \right) =
			2^{\#(\N)}
		\]
		segue dal teorema \ref{th: n calc} che esistono dunque
		delle funzioni non calcolabili.
	\end{proof}
\end{theorem}

\subsection{Forma normale ed equivalenze}
Come abbiamo già visto, è possibile enumerare le MdT, associando
loro un indice. Analogamente è possibile enumerare le funzioni
ricorsive primitive e non è difficile pensare ad un'estensione
per l'enumerazione di funzioni $\mu$-ricorsive.

I due metodi hanno in comune il fatto che si basano solamente
sui simboli usati per definire gli algoritmi. Infatti, sotto
ragionevoli ipotesi, per i nostri scopi non c'è differenza tra
un metodo di enumerazione e l'altro, purché sia \emph{effettivo}.

Data un'enumerazione effettiva, indicheremo con $\varphi_i$ la
funzione parziale che la macchina, o meglio l'algoritmo, $M_i$
calcola e chiameremo $i$ \emph{indice}. L'indice è riferito
alla macchina e non alla funzione, infatti potrebbe darsi che
per $i \neq j$, valga $\varphi_i = \varphi_j$, ma sicuramente
vale $M_i \neq M_j$.

\begin{theorem}[Padding lemma] \label{th: padding lemma}
	Ogni funzione calcolabile $\varphi_x$ ha $\# (N)$ indici.
	Vale inoltre che $\forall x$ si può costruire, mediante una
	funzione ricorsiva primitiva, un insieme infinito $A_x$ di
	indici tale che $\forall y \in A_x$, vale
	\[ \varphi_y = \varphi_x \]
	\begin{proof}
		Per ogni macchina $M_x$, se $Q = \{ q_0, \dots, q_k \}$
		è l'insieme degli stati possibili di $M_x$. Aggiungendo
		lo stato $q_{k+1}$ e la quintupla
		\[ (q_{k+1}, \#, q_{k+1}, \#, -) \]
		a tale macchina, si ottiene la macchina $M_{x_1}$ con
		$x_1 \in A_x$. Possiamo continuare all'infinito
		aggiungendo stati e quintuple che di fatto sono inutili,
		o per meglio dire non vengono mai raggiunti dalla
		macchina e non cambiano quindi cosa essa calcola.
	\end{proof}
\end{theorem}

Questo teorema ci dice che esistono infiniti algoritmi
numerabili che calcolano la stessa funzione e che alcuni di
loro sono ottenibili \emph{facilmente} da un algoritmo dato.

\begin{theorem}[Forma normale] \label{th: fn}
	Esistono un predicato $T(i, x, y)$ e una funzione $U(y)$
	calcolabili totali tali che $\forall i,x$ vale
	\[ \varphi_i(x) = U(\mu y . T (i, x, y)) \]
	Inoltre $T$ e $U$ sono ricorsive primitive.
	\begin{proof}
		Definiamo $T(i,x,y)$, detto comunemente
		\textbf{predicato di Kleene}, vero se e solo se $y$ è
		la codifica di una computazione terminante di $M_i$
		con dato iniziale $x$. Per calcolare $T$ dato $i$,
		recuperiamo $M_i$ dalla lista e cominciamo a scandire
		i valori $y$. Decodifichiamo ognuno di essi e, avendo
		come ingresso $x$ controlliamo se il risultato è una
		computazione terminante della forma
		\[ M_i(x) = c_0, c_1, \dots, c_n \]
		Se lo è, allora $c_n = (h, \start z \underline{\#})$ e
		definiamo $U$ in modo che $U(y) = z$.

		Il procedimento è effettivo e quindi $T$ e $U$ sono
		calcolabili per la tesi di Church-Turing, inoltre tale
		procedimento termina sempre e dunque $T$ e $U$ sono
		totali. Abbiamo inoltre che $T$ e $U$ sono ricorsive
		primitive perché sai le codifiche usate, che i controlli
		effettuati lo sono.
	\end{proof}
\end{theorem}

Questo teorema ci dice che tra tutti gli algoritmi che calcolano
la stessa funzione, uno di questi ha una forma privilegiata,
ossia quella \emph{normale} e di conseguenza ogni funzione ha
una forma normale.

Proviamo ad uscire un minimo dal formalismo del teorema stesso
procedendo per step. Iniziamo dal predicato di Kleene: esso è
una funzione che semplicemente ritorna vero se $y$ è la codifica
(in questo caso possiamo considerare l'enumerazione di G\"odel)
di una computazione terminante della macchina $M_i$ che prende
in input $x$.

Come abbiamo già visto una computazione, vista come una sequenza
finita di passi è anch'essa enumerabile ed è quindi possibile
immaginare che valga
\[ M_i (x) = c_0, c_1, \dots, c_n \]
dove i vari $c_i$ sono le varie configurazioni raggiunte dalla
macchina durante la computazione. Se la computazione termina
allora abbiamo che $T$ ritorna vero e che sicuramente l'ultima
configurazione, ossia $c_n$ è equivalente a
\[ c_n = (h, \start z \underline{\#}) \]
poiché siamo sicuramente giunti nello stato speciale $h$. Ho
qualche dubbio sul fatto che il cursore debba essere perforza
posizionato su un valore bianco in quanto, da quel che abbiamo
visto fino ad ora, l'unico requisito affinché una computazione
venga considerata terminata è che giunga nello stato $h$.

Ciò che è importante capire è che $U$ è la parte di stringa
della configurazione finale privata del respingente.

\begin{example}
	Riprendiamo l'esempio della MdT in grado di riconoscere la
	presenza di una sequenza di due $1$ in una stringa data in
	input.

	In quell'esempio avevamo definito una funzione di
	transizione che sovrascriveva qualunque valore incontrasse
	con un $\#$. Per qualsiasi stringa in input che contenesse
	una sequenza di due $1$ consecutivi, la macchina si sarebbe
	sempre arrestata con la seguente configurazione finale
	\[ h / \start \# \dots \underline{\#} \]
	Per il teorema dobbiamo andare a prendere il \emph{minimo}
	$y$ che rappresenta una computazione terminante della
	macchina $i$-esima che prende un certo input $x$.

	Nel caso delle macchina di Turing ci sarà in realtà un solo
	$y$ del genere (discorso differente ad esempio per le
	funzioni ricorsive in cui possiamo avere diverse politiche
	di valutazione). Nel nostro specifico, tale $y$, sarà quello
	che codifica la computazione della macchina $i$ (quella che
	abbiamo scritto noi) che prende in input la stringa
	$x = 01011$ e che quindi avrà come configurazione finale
	\[ h / \start \# \# \# \# \underline{\#} \]
	Secondo il teorema vale che
	\[ \varphi_i (x) = \varphi (01011) = U(y) = \# \# \# \# \# \]
	che in realtà andrebbe convertito in nel formalismo
	ricorsivo perché abbiamo effettivamente più senso.
\end{example}

\begin{corollary}
	Le funzioni T-calcolabili sono $\mu$-ricorsive.
\end{corollary}

Questo corollario è una diretta conseguenza del teorema di
forma normale. Possiamo quindi dire che ogni funzione calcolata
da una MdT ammette una definizione $\mu$-ricorsiva.

\begin{lemma}
	Le funzioni $\mu$-calcolabili sono T-calcolabili.
\end{lemma}

Possiamo a questo punto concludere che l'equivalenza tra MdT
e funzioni $\mu$-ricorsive.

\begin{theorem}
	Una funzione è T-calcolabili se e solo se è
	$\mu$-calcolabile.
\end{theorem}

Il teorema di forma normale e quello d'equivalenza tra MdT e
funzioni $\mu$-ricorsive ha il seguente corollario interessante
dal punto di vista informatico. La sua rilevanza nel nostro
campo è legata al fatto che le funzioni primitive ricorsive
si possono rappresentare come un programma in linguaggio
\verb|FOR|, mentre le $\mu$-ricorsive con un programma in
linguaggio \verb|WHILE|.

\begin{corollary}
	Ogni funzione calcolabile parziale può essere può essere
	ottenuta da due funzioni ricorsive primitive e una sola
	applicazione di dell'operatore $\mu$.
\end{corollary}

\subsection{Formalismo universale}
Supponiamo ora di avere a disposizione un formalismo
\textbf{universale}, in grado cioè di esprimere \emph{tutte}
le funzione calcolabili. Questo sarebbe così potente da
riuscire ad esprimere l'interprete dei propri programmi.

\begin{theorem}[Enumerazione]
	Esiste una funzione numerabile parziale $\varphi_z(i, x)$
	tale che $\forall i,x$ vale
	\[ \varphi_i(x) = \varphi_z (i, x) \]
	\begin{proof}
		Poiché la funzione $U(\mu y . T(i, x, y))$ usata nel
		teorema \ref{th: fn} è definita per composizione e
		$\mu$-ricorsione a partire da funzioni ricorsive
		primitive, essa stessa è una una funzione calcolabile
		in due argomenti $i$ e $x$. Avrà quindi un indice che
		chiamiamo $z$ e per cui vale
		\[ \varphi_z (i, x) = U(\mu y. T(i, x, y)) \]
		Applichiamo quindi il teorema di forma normale per
		ottenere
		\[ U(\mu y . T(i, x, y)) = \varphi_i (x) \]
		da qui otteniamo la tesi per transitività
		dell'uguaglianza
		\[
			\varphi_z (i, x) = U(\mu y . T(i, x, y)) =
			\varphi_i (x)
		\]
		Più informalmente la macchina $M_z$ recupera la
		descrizione della macchina $M_i$ e la applica a $x$.
	\end{proof}
\end{theorem}

Il teorema, scritto in forma molto compatta, in sostanza ci
dice che esiste un algoritmo (o una MdT) $z$ che prende in
input un altro algoritmo (o MdT) $i$, i dati $x$ su cui lavora
$i$ e restituisce lo stesso risultato dell'algoritmo $i$-esimo
applicato a $x$. In genere la macchina di Turing $z$ viene
chiamata \textbf{macchina di Turing universale}.

Passiamo ora ad un teorema che possiamo vedere un po' come il
duale del teorema di enumerazione. Enunceremo una prima versione
semplificata e poi la sua forma generale.

\begin{theorem}[Teorema del parametro s-1-1]
	\label{th: s-1-1}
	Esiste una funzione $s$ calcolabile totale tale che per ogni
	$i$, $x$ e $y$ vale
	\[ \lambda y . \varphi_i (x, y) = \varphi_{s (i, x)} (y) \]
	\begin{proof}
		Da $i$ prendiamo l'$i$-esima MdT e scriviamo sul nastro
		di $M_i$ l'input $x$ e $y$. Questi due passi definiscono
		un algoritmo il quale ha un indice $j$ per la tesi di
		Church-Turing. Tale indice mi identifica la macchina che
		calcola
		\[ \varphi_{s(i,x)} \]
		A questo punto usiamo il padding lemma per trovare una
		$h$ maggiore di tutti i valori ottenuti fino ad ora.
		Otteniamo così una funzione strettamente crescente che
		è anche iniettiva.
	\end{proof}
\end{theorem}

Come possiamo notare nella prima funzione abbiamo due argomenti
e nella seconda uno solo. Il fatto è che quando $x$ viene
considerato come un \emph{parametro}, allora è possibile
calcolare la prima funzione utilizzando un altra macchina a
partire dall'indice $i$.

\begin{example}
	Prendiamo ad esempio la funzione
	\[ x + y \]
	Una volta fissata la $x$ ad un certo valore, supponiamo
	$2$, la $x$ a questo punto non è più un argomento ma
	diventa un parametro. A questo punto la funzione
	\[ 2 + y \]
	può essere calcolata da un'altra macchina che a regola
	dovrebbe essere un po' più efficiente di quella di partenza.
\end{example}

Questo sta alla base della \textbf{valutazione parziale} che è
molto utile in quei contesti in cui si vuole mantenere un alto
livello di generalizzazione.

\begin{theorem}[Teorema del parametro s-m-n]
	\label{th: s-m-n}
	Per ogni $m, n \geq 0$ esiste una funzione calcolabile
	totale (iniettiva) $s_n^m$ con $m+1$ argomenti, tale che
	per ogni $x, y_1, \dots, y_m$, vale
	\[
		\varphi_{s_n^m (x, y_1, \dots, y_m)}^{(n)} =
		\lambda z_1, \dots, z_n .
		\varphi_x^{(m+n)} (y_1, \dots, y_m, z_1, \dots, z_n)
	\]
\end{theorem}

Si noti come il teorema del parametro e quello di enumerazione
siano in un certo senso l'inverso l'uno dell'altro. Infatti
l'uno "abbassa" un argomento nella posizione di indice, mentre
l'altro "innalza" un indice nella posizione di argomento.

\begin{theorem}[Espressività]
	Un formalismo è \textbf{Turing-equivalente}, ossia calcola
	tutte e sole le funzioni T-calcolabili ed è universale, se
	e solo se
	\begin{itemize}
		\item Ha un algoritmo universale (vale cioè il teorema
		      di enumerazione).
		\item Vale il teorema del parametro.
	\end{itemize}
\end{theorem}

Grazie al teorema del parametro si dimostra un altro teorema
che ha un ruolo fondamentale sia in informatica che in teoria
della calcolabilità.

\begin{theorem}[Punto fisso]
	per ogni funzione $f$ calcolabile totale $\exists n$ tale
	che
	\[ \varphi_n = \varphi_{f(n)} \]
	\begin{proof}
		Definiamo la seguente funzione
		\[
			\psi (u, z) = \varphi_{d(u)} (z) =
			\begin{cases}
				\varphi_{\varphi_u (u)} (z) &
				\text{se } \varphi_u (u) \downarrow \\
				\text{indefinita}           &
				\text{altrimenti}
			\end{cases}
		\]
		Per il teorema del parametro, $d(u)$ è totale e
		iniettiva (e non dipende da $f$). Data $f$, allora
		anche $f \circ d$ è calcolabile e sia $v$ proprio
		un indice tale che
		\[ \varphi_v(x) = f(d(x)) \]
		Tale funzione è totale (perché sia $d$ che $f$ lo sono)
		e quindi $\varphi_v (v)$ converge. Pertanto, in accordo
		con la definizione data in precedenza di $\psi (u,z)$
		abbiamo che
		\[ \varphi_{d(v)} = \varphi_{\varphi_v(v)} \]
		Calcoliamo ora $d(v)$ e supponiamo che il risultato sia
		$n$, cioè poniamo
		\[ n = d(v) \]
		Dimostriamo che è un punto fisso di $f$. Infatti vale
		la seguente catena di eguaglianze
		\[
			\varphi_n  = \varphi_{d(v)}
			= \varphi_{\varphi_v (v)}
			= \varphi_{f(d(v))}
			= \varphi_{f(n)}
		\]
		Nell'eguaglianza più a sinistra si sfrutta l'iniettività
		che viene garantita dal teorema del parametro.
	\end{proof}
\end{theorem}

Un tale indice viene detto \textbf{punto fisso} di $f$. Il
teorema inoltre ci dice che la funzione $f$ trasforma algoritmi
in algoritmi, proprio come fa un compilatore.

In altre parole il punto fisso non cambia la funzione calcolata
ma trasforma l'algoritmo $P_n$ nell'algoritmo $P_{f(n)}$ con la
stessa semantica.

\begin{property}
	Nelle ipotesi del teorema di ricorsione
	\begin{itemize}
		\item Il punto fisso è calcolabile mediante una funzione
		      totale (iniettiva) $g$ a partire dall'indice di
		      $f$.
		\item Ci sono $\# (\N)$ punti fissi di $f$.
	\end{itemize}
	\begin{proof}
		Per dimostrare il primo punto prendiamo $h(x)$
		calcolabile totale tale che $\forall n$ vale
		\[ \varphi_{h(x)} (n) = \varphi_x (d(n)) \]
		Allora vale
		\[ g(x) = d(h(x)) \]
		Il secondo punto segue invece dal teorema
		\ref{th: n calc}.
	\end{proof}
\end{property}

