\section{Problemi e funzioni}
Per il momento abbiamo usato i nostri costrutti per calcolare
una funzione (la somma per esempio) o per decidere
l'appartenenza di un elemento ad un insieme (decidere se una
stringa è palindroma).

In questa prima parte del corso andremo a definire meglio il
concetto di \textbf{problema} e di \textbf{funzione} che, nel
nostro caso, non hanno l'accezione cui siamo abituati.

Un esempio di \emph{problema} è la domanda: "qual è il massimo
comun divisore tra $x$ e $y$?". Se sostituiamo a $x$ e a $y$
dei valori, per esempio 34 e 98, otteniamo un \textbf{caso}
del problema.

\begin{definition} \label{def: T-calcolabile}
	Siano $\Sigma$, $\Sigma_0$ e $\Sigma_1$ tali che
	\[ \#, \start \notin \Sigma_0 \cup \Sigma_1 \]
	e
	\[ ]\Sigma_0 \cup \Sigma_1 \subset \Sigma \]
	allora diciamo che una funzione
	\[ f : \Sigma_0 \to \Sigma_1 \]
	è \textbf{Turing calcolabile} o \textbf{T-calcolabile},
	se e solo se
	\begin{gather*}
		\forall w \in \Sigma_0^* : f(w) = z \\
		\Updownarrow \\
		(q_0, \underline{\start} w) \to_M^*
		(h, \start z \underline{\#})
	\end{gather*}
	Si dice anche che $f$ è T-calcolabile se esiste una MdT
	$M$ che la calcola.
\end{definition}

Ora che abbiamo la definizione precisa di cosa sia una
funzione T-calcolabile proviamo a fare una cosa analoga per
il linguaggio WHILE che abbiamo definito in precedenza.

\begin{definition} \label{def: while-calcolabile}
	Diciamo che una funzione
	\[ f : \Var \to \N \]
	è \textbf{WHILE-calcolabile} oppure diciamo che un comando
	$C$ \textbf{calcola} $f$, se e solo se
	\begin{gather*}
		\forall \sigma \in \Var \to \N : f(x) = n \\
		\Updownarrow \\
		(C, \sigma) \to^* \sigma' \quad \land \quad
		\sigma'(x) = n
	\end{gather*}
\end{definition}

Notiamo che la variabile $x$ di input è anche la variabile
di output, ossia quella che contiene il risultato.

\subsection{Codifiche}
Ci chiediamo ora se per una funzione $f$ che non opera su
dati sotto formato di stringa, memorie o numeri naturali,
le nozioni di calcolabilità che abbiamo definito fino ad ora
sono ancora valide.

Se così non fosse dovremmo ridefinire ogni volta tali nozioni
per ogni dominio di ogni funzione con un formato differente da
quelli che abbiamo già incontrato.

Per superare il problema si fa uso di opportune
\textbf{codifiche} dei dati, ossia funzioni che svolgono
il seguente compito.
\begin{enumerate}
	\item Dato $x$ in formato $A$, lo si codifica in un formato
	      $B$ con cui riusciamo a calcolare.
	\item Si applica la MdT a $y$ e si ottiene il risultato $z$
	      (se la computazione termina) in formato $B$.
	\item Si traduce $z$ dal formato $B$ al formato $A$.
\end{enumerate}
D'ora in avanti considereremo solo i numeri naturali come i
nostri dati. Abbiamo però bisogno che la funzione di codifica
sia \emph{biunivoca}.

\begin{example}
	La seguente funzione codifica coppie di naturali come un
	singolo naturale ed è detta codifica a
	\textbf{coda di colomba}.
	\[ (x, y) \to \frac{1}{2} (x^2 + 2 x y + y^2 + 3 x + y) \]
	la cui decodifica, ossia la funzione inversa è la seguente
	\[
		n \to (n - \frac{1}{2} k \cdot (k + 1),
		k - (n - \frac{1}{2} k \cdot (k + 1))
	\]
	dove $k=\lfloor \frac{1}{2}(\sqrt{1+8\cdot n}-1)\rfloor$.
\end{example}

A prescindere dall'esempio, possiamo dire che le proprietà
basilari dei formalismi e della classe di funzioni calcolate,
non cambiano al variare del formato dei dati su cui operano.

\begin{definition} \label{def: funzione totale}
	Diciamo che una funzione $f : A \to B$, sottoinsieme di
	$A \times B$ è una \textbf{funzione totale} se e solo se
	\begin{itemize}
		\item La funzione è \emph{definita ovunque}, ossia se
		      $\forall a \in A$, $\exists b \in B$ tale che la
		      coppia $(a, b) \in f$.
		\item Vi è \emph{unicità}, ossia se, date le coppie
		      $(a, b) \in f$ e $(a, c) \in f$, allora $b=c$.
	\end{itemize}
\end{definition}

Una funzione può essere calcolabile ma non totale, per esempio
la macchina di Turing che non termina mai vista all'inizio del
corso.

\begin{definition} \label{def: funzione parziale}
	Diciamo che una funzione $f : A \to B$ è \textbf{parziale}
	se è un sottoinsieme di $A \times B$ tale che
	\begin{itemize}
		\item Vi è \emph{unicità}, ossia se, date le coppie
		      $(a, b) \in f$ e $(a, c) \in f$, allora $b=c$.
		\item Esiste al più un $b \in B$ tale che $f(a) = b$.
	\end{itemize}
	e quindi non si richiede che $f$ sia definita ovunque.
\end{definition}

Introduciamo ora un po' di notazione utile a quello che faremo
più avanti. Data una funzione $f : A \to B$
\begin{itemize}
	\item Diremo che $f$ è \textbf{definita} o
	      \textbf{converge su $a$} ($f(a) \downarrow$) se
	      $\exists b$ tale che $(a, b) \in f$ (cioè
	      $f(a) = b$).
	\item Diremo che $f$ \textbf{non è definita} o che
	      \textbf{diverge} ($f(a) \uparrow$) se $\nexists b$
	      tale che $(a, b) \in f$.
\end{itemize}
Chiamiamo inoltre
\begin{itemize}
	\item \textbf{Dominio} di $f$ l'insieme
	      \[ \{ a \in A | f(a) \downarrow \} \]
	      che coincide con lo spazio di partenza ($A$) se e
	      solo se la funzione è totale.
	\item \textbf{Codominio} di $f$ l'insieme $B$.
	\item \textbf{Immagine} di $f$ l'insieme
	      \[ \{ b \in B | \exists a \in A : f(a) = b \} \]
\end{itemize}

Detto questo vogliamo capire qual è la relazione tra funzioni
e algoritmi. Una funzione possiamo vederla come un insieme di
coppie (\emph{argomento}, \emph{risultato}) (o (\emph{input},
\emph{output}) se preferiamo la notazione più informatica) ma
non ci dice come il risultato (o l'output) venga calcolato.

Di conseguenza non ci sono due funzioni diverse che per uno
stesso argomento restituiscono lo stesso risultato. In termini
insiemistici possiamo dire che non esistono due insiemi diversi
che hanno gli stessi elementi.
\begin{tcolorbox}
	Un algoritmo è invece una \textbf{rappresentazione finita}
	di una funzione, in quanto specifica come si calcola il
	risultato a partire dall'argomento. In questo caso possiamo
	certamente avere più algoritmi che calcolano la stessa
	funzione.
\end{tcolorbox}

\subsection{Funzioni calcolabili}
D'ora in avanti proveremo a capire
\begin{itemize}
	\item Quali sono le \textbf{funzioni calcolabili} e di
	      quali proprietà godono.
	\item Se esistono funzioni totali o parziali che non sono
	      calcolabili. Ovvero per cui si dimostra che non esiste
	      un algoritmo che le calcoli.
\end{itemize}

\begin{example}
	Prendiamo ora come esempio la
	\textbf{congettura di Goldbach}, la quale ci dice che ogni
	numero pari maggiore di 2 è esprimibile come somma di due
	numeri primi.

	Da questa congettura (mai dimostrata) nasce la
	\textbf{funzione di Goldbach}, definita come segue con
	$gb : \N \to \N$
	\[
		gb(n) = \begin{cases}
			0 & \text{se la congettura è vera} \\
			1 & \text{altrimenti}
		\end{cases}
	\]
	La congettura non è stata ancora dimostrata ma un algoritmo
	per calcolarla esiste, solo che non sappiamo quale sia.

	Se ad esempio volessimo decidere se la funzione è
	T-calcolabile, basterebbe prendere una MdT che ritorna
	sempre 0 se la congettura è vera o una MdT che ritorna
	sempre 1 se è falsa. Il problema è che fin tanto che la
	congettura non è dimostrata, non sappiamo quale delle due
	scegliere.
\end{example}

