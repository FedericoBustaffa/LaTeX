\section{Codifica}
Per la costruzione della nostra MdT universale useremo la
codifica \emph{unaria}, ossia codificheremo i vari stati, simboli
ecc. tramite una sequenza di $\mid$.

Dato che abbiamo tre nastri dobbiamo definire una funzione di
transizione che tiene di conto dello stato della macchina (che
rimane unico) e dei tre simboli su cui si trovano rispettivamente
i tre cursori. In generale possiamo dire che, ad ogni passo di
computazione, la macchina, si basa sullo stato corrente e su
ognuno dei tre simboli indicati dal cursore. Sempre ad ogni passo
(in generale) ogni cursore potrebbe muoversi, e lo stato potrebbe
cambiare.

Per codificare una MdT abbiamo bisogno di due funzioni di
codifica, una per la codifica di una generica macchina $M$ e una
per la codifica del dato $w$ su cui questa opera. Una volta
codificata $M$ e il dato $w$ su cui opera, possiamo concatenare
le due codifiche per ottenere una codifica completa su cui la
MdT universale $U$ che andremo a costruire potrà operare.

\subsection{Codifica per stati, simboli e direzioni}
Supponiamo di avere i seguenti insiemi ausiliari
\begin{gather*}
	Q_* = \{ q_0, q_1, \dots \} \\
	\Sigma_* = \{ \sigma_0, \sigma_1, \dots \}
\end{gather*}
con $h \notin Q_*$ e $L, R, - \notin \Sigma_*$ (che non sono
quelli su cui opera $U$). In questo modo ogni MdT $M_k$ avrà
l'insieme degli stati $Q_k$ e l'insieme dei simboli $\Sigma_k$
inclusi rispettivamente in $Q_*$ e $\Sigma_*$.

Il prossimo passo consiste nel rappresentare gli elementi di
$Q_*$ e $\Sigma_*$ come stringhe generate dalla concatenazione
del simbolo $\mid$. Vogliamo quindi definire una funzione di
codifica
\[
	\kappa : Q_* \cup \{ h \} \cup \Sigma_* \cup \{ L, R, - \}
	\rightarrow \{ \mid \}^*
\]
in grado di codificare stati, simboli e direzioni in questo modo:
\begin{gather*}
	q_i \mapsto \mid^{i+2}      \quad h \mapsto \mid \\
	\sigma_j \mapsto \mid^{j+4} \\
	L \mapsto \mid \quad R \mapsto \mid^2 \quad - \mapsto \mid^3
\end{gather*}
Il motivo per cui $q_i \mapsto \mid^{i+2}$ è che abbiamo già $h$
codificato come $\mid$ e dunque, partendo da $q_0$ abbiamo che
$q_0 \mapsto \mid^2 = \mid \mid$. Discorso analogo per la
codifica dei simboli.

\`E immediato notare però che la funzione $\kappa$ non è
biunivoca in quanto sia $h$ che $L$ vengono codificati in $\mid$
(così come tanti altri stati e simboli che condividono la stessa
codifica). In realtà a noi interessa considerare $\kappa$
ristretta all'insieme di appartenenza dell'oggetto che vogliamo
codificare, ecco che la funzione diventa biunivoca.

\subsection{Codifica delle tuple}
Arrivati a questo punto è lecito chiedersi su quale alfabeto
opera $U$. Sappiamo che fa uso del simbolo "$\mid$" ma da solo
non permette di fare granché. Definiamo quindi il seguente
alfabeto
\[ \{ \mid, c, d, \#, \start \} \]
sotto l'ipotesi che l'intersezione tra questo e
$\Sigma_* \cup Q_*$ sia vuota. Come possiamo notare ci sono due
simboli ($c$ e $d$) sconosciuti. Il loro significato sarà chiaro
a breve. Prima facciamo il punto della situazione: abbiamo una
funzione $\kappa$ che, se ristretta ad un certo insieme, è in
gado di codificare stati, simboli e direzioni in una stringa
composta da un certo numero di "$\mid$".

Quel che vogliamo fare ora è codificare tuple intere. Per farlo
possiamo certamente usare la funzione $\kappa$ e codificare ogni
singolo elemento della tupla. Il primo problema che salta
all'occhio è che una volta codificata una tupla, non c'è modo di
capire dove inizia o dove finisce la codifica di un certo stato,
simbolo o direzione. L'altro problema è che non tutte le tuple
sono definite per la funzione $\delta$. Ecco che vengono
introdotti $c$ e $d$:
\begin{itemize}
	\item Il simbolo $c$ ha la funzione di separare le codifiche
	      di stati, simboli e direzioni. Senza questo, la
	      codifica ci restituirebbe una stringa di "$\mid$"
	      concatenate, che rappresentano l'intera tupla e sarebbe
	      quindi impossibile capire quando inizia o finisce la
	      codifica di ciascun oggetto.
	\item Il simbolo $d$ serve a codificare i casi in cui
	      la funzione $\delta$ non è definita per certi stati
	      iniziali e per certi simboli sul nastro. In quei casi
	      la codifica restituisce il simbolo $d$.
\end{itemize}
Fatte queste premesse proviamo a codificare una generica MdT $M$
definita come segue
\[ M = (Q, \Sigma, \delta, s) \]
con $s$ stato iniziale. Per prima cosa ordiniamo l'insieme degli
stati
\[ Q = \{ q_{i_1}, \dots, q_{i_k} \} \]
e l'insieme dei simboli
\[ \Sigma = \{ \sigma_{j_1}, \dots, \sigma_{j_l} \} \]
in modo tale che
\[
	p \leq p' \implies i_p \leq i_{p'} \quad
	\land \quad j_p \leq j_{p'}
\]
Non è ben chiaro perché si usino gli indici $i$ e $j$ se poi c'è
un ulteriore indice. Non ci stiamo nemmeno riferendo all'insieme
degli stati della macchina $i$ o $j$ perché appunto gli indici
sono diversi. Forse è solo una questione di notazione che non
conosco. Anche per l'ordinamento di stati e simboli non sembra
esserci bisogno di $i$ e $j$.

Il doppio pedice per stati e simboli potrebbe portare un po' di
confusione. Quando consideriamo ad esempio l'insieme degli stati
$Q = \{ q_{i_1}, \dots, q_{i_k} \}$ probabilmente ci stiamo
riferendo ad un certo insieme $Q_i$ con i vari stati $q_i$ a cui
viene dato un ordine (il secondo pedice) ma non sono
assolutamente certo.

La codifica di ogni $n$-upla avviene tramite una funzione
$S_{p,q}$ in questo modo
\[
	S_{p,q} = c \; \kappa (q_{i_p})
	\; c \; \kappa (\sigma_{j_q})
	\; c \; \kappa (q)
	\; c \; \kappa (\sigma)
	\; c \; \kappa (D) \; c
\]
se $\delta (q_{i_p}, \sigma_{j_q}) = (q, \sigma, D)$. Completiamo
con la codifica dei casi in cui $\delta$ non è definita:
\[
	S_{p,q} = c \; \kappa (q_{i_p})
	\; c \; \kappa (\sigma_{j_q})
	\; c \; d \; c \; d \; c \; d \; c
\]
se $\delta(q_{i_p}, \sigma_{j_q})$ non è definita.

\begin{example}
	Vediamo un esempio che applica la codifica appena descritta
	considerando la MdT
	\[
		\hat{M} = (\{ q_2 \}, \{ \sigma_1, \sigma_3, \sigma_5 \},
		\delta, q_2)
	\]
	dove
	\begin{gather*}
		\delta(q_2, \sigma_1) = \quad (h, \sigma_5, -)
		\quad \mapsto S_{1,1} \\
		\delta(q_2, \sigma_3) = \quad (q_2, \sigma_1, R)
		\quad \mapsto S_{1,2}
	\end{gather*}
	allora $k=1$ ($i_1=2$) e $l = 3$ ($j_1 = 1$, $j_2 = 3$,
	$j_3 = 5$) e $S_{1,1}$, $S_{1,2}$, $S_{1,3}$ sono definiti
	come segue
	\begin{gather*}
		S_{1,1} = c \mid^4 c \mid^5 c \mid c \mid^9 c \mid^3 c \\
		S_{1,2} = c \mid^4 c \mid^7 c \mid^4 c \mid^5 c \mid^2 c \\
		S_{1,3} = c \mid^4 c \mid^9 c \; d \; c \; d \; c \; d \; c
	\end{gather*}
\end{example}

Torniamo a noi e cerchiamo di definire una funzione $\rho$ che
mandi una generica MdT $M$ in una stringa fatta di soli caratteri
$\mid$, $c$ e $d$ che verrà racchiusa tra due $c$. Ciò che ci
manca è sapere quale sia lo stato iniziale di $M$ che
codificheremo e prefiggeremo alla codifica della funzione di
transizione $\delta$, nel modo seguente:
\[
	\rho (M) = c \; \kappa (s) \; c \;
	S_{1,1} S_{1,2} \dots
	S_{1,l} S_{2,1} \dots S_{2,l} \dots
	S_{k,1} S_{k,2} \dots S_{k,l} \; c
\]
In questo modo abbiamo generato una stringa da cui è possibile
tornare indietro o ad una MdT o ad un qualcosa che non lo è in
caso la stringa non sia l'immagine di una MdT.

Siamo riusciti a codificare la MdT $M$ ma non abbiamo ancora
finito in quanto ci serve anche la codifica del dato
$w = \sigma'_0 \dots \sigma'_n$ in ingresso. L'ultimo passo
della codifica è ottenuto tramite la funzione $\tau$ che ci
permette di ottenere
\[ \rho(M) \tau(w) \]
ossia la codifica completa della macchina e del suo input. Dove
la funzione $\tau$ è definita come segue
\[
	\tau(\sigma'_0 \dots \sigma'_n) =
	c \; \kappa(\sigma'_0) \;
	c \; \kappa(\sigma'_n) \; c
\]
Si noti che tre $c$ separano la codifica di $M$ da quella $w$.