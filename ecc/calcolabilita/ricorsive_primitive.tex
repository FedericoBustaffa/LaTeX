\section{Funzioni ricorsive primitive}
Iniziamo con il definire due delle funzioni definite per
\emph{ricorrenza} più popolari, il fattoriale e la successione
di Fibonacci.

Iniziamo con il \emph{fattoriale}, definito come una coppia
di equazioni, la prima per il caso base, ossia quando $x = 0$
e la seconda per tutti gli altri casi, ossia per ogni $x > 0$.
\[
	!(x) = \begin{cases}
		1        & \text{se } x = 0 \\
		!(n - 1) & \text{se } x > 0
	\end{cases}
\]
Proviamo a scrivere una versione WHILE e una versione FOR del
fattoriale
\begin{verbatim}
    fatt = 1;
    while x > 0 do
        fatt = fatt * x;
        x = x - 1;
\end{verbatim}
in questo caso salviamo il risultato nella variabile
\verb|fatt| che è la stessa che usiamo per ritornare il
risultato.

La \emph{successione di Fibonacci} presenta invece due casi
base e un caso definito per ricorrenza ed è definita come
segue
\[
	fib(x) = \begin{cases}
		0                       & \text{se } x = 0 \\
		1                       & \text{se } x = 1 \\
		fib(x - 1) + fib(x - 2) & \text{se } x > 1
	\end{cases}
\]
Ora vogliamo capire quali sono le regole per formare bene
delle formule ricorsive ed è qui che prenderemo un po' di
notazione in prestito dal $\lambda$-calcolo. Nel caso del
fattoriale possiamo scrivere
\[ \lambda x . !(x) \]
per dire che il fattoriale dipende solo da $x$. Possiamo anche
scrivere un qualcosa di questo tipo
\[ \lambda x . x + y \]
per definire una funzione che prende $x$ e restituisce una
funzione che dipende da $y$. Abbiamo quindi un modo per
\emph{costruire} delle funzioni specificando esattamente quali
sono i suoi argomenti.

\begin{definition}
	Le \textbf{funzioni ricorsive primitive} sono la minima
	classe $\C$ da $\N^n$, con $n \geq 0$, in $\N$ cui
	appartengono
	\begin{itemize}
		\item \textbf{Zero}: una funzione che prende $k \geq 0$
		      di argomenti e ritorna 0.
		      \[ \lambda x_1, \dots, x_k . 0 \]
		\item \textbf{Successore}: che prende un argomento solo
		      e restituisce il suo successore
		      \[ \lambda x . x + 1 \]
		\item \textbf{Identità}: che prende $k$ argomenti e
		      ritorna l'argomento $i$-esimo con $1\leq i\leq k$.
		      \[ \lambda x_1, \dots, x_k . x_i \]
		      Viene anche chiamata \textbf{proiezione}.
	\end{itemize}
	Questi sono anche detti \textbf{schemi primitivi di base}.
	La classe $\C$ che stiamo provando a definire è inoltre
	\emph{chiusa} per
	\begin{itemize}
		\item \textbf{Composizione}: Se $g_1, \dots, g_k \in \C$
		      sono funzioni in $m$ variabili, e $h \in \C$ è
		      una funzione in $k$ variabili, anche la loro
		      composizione
		      \[
			      \lambda x_1, \dots x_m .
			      h(g_1(x_1, \dots, x_m), \dots,
			      g_k(x_1, \dots, x_m)
			      )
		      \]
		      appartiene a $\C$.
		\item \textbf{Ricorsione primitiva}: Se $h \in \C$
		      è una funzione in $k+1$ variabili, $g \in \C$
		      è una funzione in $k-1$ variabili definita da
		      \[
			      \begin{cases}
				      f(0, x_2, \dots, x_k)       & =
				      g(x_2, \dots, x_k)              \\
				      f(x_1 + 1, x_2, \dots, x_k) & =
				      h(x_1, f(x_1, \dots, x_k),
				      x_2, \dots, x_k)
			      \end{cases}
		      \]
	\end{itemize}
\end{definition}

\begin{tcolorbox}
	Dato che $\C$ è la \emph{minima} classe che soddisfa le
	condizioni espresse sopra, affinché $f$ sia ricorsiva
	primitiva, occorre e basta che sia una successione finita,
	o \textbf{derivazione}, della seguente forma
	\[ f_1, \dots, f_n \]
	tale che $f = f_n$ e per ogni $i$ tale che
	$1 \leq i \leq n$ vale uno dei seguenti casi:
	\begin{itemize}
		\item $f_i \in C$ è uno \emph{Zero} o è
		      l'\emph{Identità}.
		\item $f_i$ è ottenibile tramite l'applicazione delle
		      regole di \emph{Combinazione} e
		      \emph{Ricorsione primitiva} da $f_j$ con $j < i$.
	\end{itemize}
\end{tcolorbox}

Tra i requisiti che abbiamo appena descritto perché una
funzione venga definita \emph{ricorsiva primitiva}, quello
meno intuitivo è sicuramente è quello che riguarda proprio
la ricorsione primitiva.

Come vediamo, noi possiamo definire una funzione di se stessa,
ma con delle limitazioni. Come possiamo vedere abbiamo un
primo caso in cui il primo argomento è $0$ e non c'è una
chiamata ricorsiva, siamo quindi davanti ad un caso base.

Più complesso è il secondo caso, in cui diciamo che la funzione
su $k$ argomenti ritorna il primo argomento decrementato,
effettua una chiamata ricorsiva su tutti gli argomenti e lascia
i rimanenti invariati.

Resistiamo per un esempio e proviamo a fare il punto della
situazione. Prima di fare l'esempio definiamo la somma tramite
le regole appena descritte.
\[
	\begin{array}{ll}
		f_1 & = \lambda x.x                    \\
		f_2 & = \lambda x.x + 1                \\
		f_3 & = \lambda x_1, x_2, x_3 . x_2    \\
		f_4 & = f_2 (f_3 (x_1, x_2, x_3))      \\
		f_5 & = \begin{cases}
			        f_5 (0, x_2)     & = f_1 (x_2) \\
			        f_5 (x + 1, x_2) & =
			        f_4 (x_1, f_5(x_1, x_2), x_2)
		        \end{cases}
	\end{array}
\]
Qui l'idea, avendo come unica funzione di somma la funzione
successore, è quella di calcolare il successore del primo
numero tante volte quanto è il secondo numero.

\begin{example}
	Proviamo a calcolare $2 + 3$ con la somma che abbiamo
	appena definito
	\[
		\begin{array}{l}
			f_5(2, 3) =                         \\
			f_4 (1, f_5(1, 3), 3) =             \\
			f_4 (1, f_4(0, f_5 (0, 3), 3), 3) = \\
			f_4 (1, f_4(0, f_1 (3), 3), 3) =    \\
			f_4 (1, f_4(0, 3, 3), 3) =          \\
			f_4 (1, f_2(f_3(0, 3, 3)), 3) =     \\
			f_4 (1, f_2(3), 3) =                \\
			f_4 (1, 4, 3) =                     \\
			f_2 (f_3 (1, 4, 3)) =               \\
			f_2 (4) = 5
		\end{array}
	\]
	Applicare la formula non è niente di difficile e forse
	non è più di tanto istruttivo.
\end{example}

Dunque quello che interessa principalmente sapere a noi è 
cosa sia una funzione ricorsiva primitiva e a quali regole 
sottostare per definirne una.

