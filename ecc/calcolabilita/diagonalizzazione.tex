\section{Diagonalizzazione}
Fino ad ora abbiamo visto che formalismi come programmi FOR
e funzioni ricorsive primitive calcolano \emph{solo} funzioni
totali. Ci chiediamo adesso se esiste un formalismo che esprime
tutte le funzioni calcolabili e per di più solo quelle totali.

La risposta è no e la \textbf{funzione di Ackermann} ne è un
esempio, la quale è totale ma non è ricorsiva primitiva.
Potremmo quindi pensare di estendere il formalismo per far sì
che anche questa funzione sia ricorsiva primitiva e chiederci
se a questo punto esiste un formalismo in grado di esprimere
tutte e sole le funzioni totali.

La risposta è ancora no e proveremo a dimostrarlo tramite un
metodo che prende il nome di \textbf{diagonalizzazione}. Questo
metodo, independente dal formalismo sul quale viene applicato,
a patto che quest'ultimo sia un formalismo con cui si possano
definire solo funzioni totali, permette di dimostrare che quel
formalismo non riesce ad esprimere tutte le funzioni calcolabili
totali in quanto ne manca almeno una che intuitivamente lo è.
\begin{enumerate}
	\item Ragioniamo in termini di funzioni ricorsive primitive
	      e chiamiamo quindi $f_n$ la funzione definita dalla
	      $n$-esima derivazione degli schemi primitivi di base.
	      Dato che le funzioni ricorsive primitive e le sue
	      possibili derivazioni sono stringhe finite prese da
	      un alfabeto finito, possiamo (ad esempio tramite il
	      processo di g\"odelizzazione) enumerarle.
	\item Definiamo la funzione
	      \[ g(x) = f_x(x) + 1 \]
	      che è una funzione calcolabile e totale in quanto
	      $f_x$ è l'$x$-esima derivazione di una funzione
	      ricorsiva primitiva.
	\item Ci si rende conto che $g$ non si trova nelle lista
	      delle funzioni ricorsive primitive perché $\forall x$
	      vale che
	      \[ g(x) = f_x(x) + 1 \]
	      e quindi $\forall x$ vale che
	      \[ g(x) \neq f_x(x) \]
	      In altre parole la funzione $g$ usa l'$x$-esima
	      funzione nella lista, gli applica $x$ e ci somma $1$,
	      ma l'$x$-esima funzione nella lista ritorna un
	      certo risultato $y$ e non $y + 1$.
\end{enumerate}
Ecco che la funzione $g$, che sicuramente è totale e calcolabile
non appartiene alla lista che abbiamo definito, in particolare
nel nostro caso non è una funzione ricorsiva primitiva.

\subsection{Diagonalizzazione per funzioni parziali}
Siamo quindi obbligati a considerare le funzioni
\hyperref[def: funzione parziale]{parziali} le quali non sono
definite su tutto $\N$. Cerchiamo quindi di dimostrare che
la diagonalizzazione non si applica anche a queste funzioni.
Come prima possiamo enumerare tutte le nostre funzioni e
dunque prendiamo $\psi_n$, l'$n$-esima funzione presente nella
nostra lista delle funzioni, e proviamo a diagonalizzare.
Poniamo dunque
\[ \varphi (x) = \psi_x (x) + 1 \]
Supponiamo ora che $\varphi$ sia rappresentata dall'$n$-esimo
algoritmo: non possiamo tuttavia concludere che
\[ \varphi \neq \psi_n \]
perché $\psi_n(n)$ potrebbe non essere definita e dunque
divergere. Se $\psi_n(n)$ diverge, lo fa anche $\psi_n(n)+1$
e dunque le due funzioni sono equivalenti.

Prendiamo ad esempio la seguente funzione
\[ div(x,y) = \lfloor x / y \rfloor \]
che è definita solo se $y \neq 0$. Ci chiediamo quindi se sia
possibile estendere tutte le funzioni parziali a totali. Come
vedremo più avanti la risposta è no perché non sempre c'è un
algoritmo che calcola la versione estesa.

Torniamo però al caso della divisione. Se ad esempio definissimo
accuratamente il dominio della funzione, per esempio in questo
modo
\[ div : \N \times \N \backslash \{ 0 \} \to \N \]
avremmo comunque il problema che non tutte le coppie di naturali
sono coperte. Introduciamo quindi un simbolo speciale
$* \notin \N$ in modo da avere ancora una funzione per tutte le
possibili coppie di naturali
\[ div^* : \N \times \N \to \N \cup \{ * \} \]
definita in questo modo
\[
	div^* (x, y) = \begin{cases}
		div(x, y) & \text{se } y \neq 0 \\
		*         & \text{se } y = 0
	\end{cases}
\]
Non vogliamo però liberarci della parzialità e dunque abbiamo
bisogno di un modo per definire anche le funzioni parziali.

