\chapter{Cifrari a chiave pubblica}
Nei cifrari simmetrici si ha un grosso problema, ovvero, lo \textbf{scambio della chiave}, che, come sappiamo, deve
essere la stessa per entrambi gli utenti.

Fino ad ora abbiamo sempre assunto che i due utenti fossero gi\`a in possesso della chiave e abbiamo solo parlato del
metodo di cifratura e decifrazione. Come abbiamo visto i messaggi scambiati sono cifrati e dunque la comunicazione \`e
sicura ma come avviene lo scambio della chiave ?
\begin{itemize}
	\item Se avviene di persona allora tanto vale scambiarsi direttamente il messaggio.
	\item Se avviene in chiaro non ha pi\`u senso cifrare il messaggio dato che chiunque potrebbe intercettare la
	      chiave e decifrarlo senza sforzo.
	\item Se inviassimo la chiave cifrata si innescherebbe lo stesso problema all'infinito: il destinatario avrebbe
	      bisogno della chiave di cifratura per decifrare e dunque si dovrebbe inviare un'altra chiave e cos\`i via.
\end{itemize}
I \textbf{cifrari a chiave pubblica} risolvono il problema.

\section{Soluzione ingenua}
Se abbiamo un sistema con $N$ utenti, ogni utente pu\`o memorizzare $N-1$ chiavi diverse e condivise con ciascun altro
utente.

In questo modo abbiamo un numero quadratico di chiavi nel numero di utenti del sistema.

Quando un utente $i$ vuole comunicare con l'utente $j$ manda un messaggio a $j$ cifrandolo con la chiave $k_j$.
L'utente $j$ a questo punto decifra il messaggio con la sua chiave $k_j$ e invia un messaggio a $i$ cifrandolo con
la chiave $k_i$.

\section{TTP}
Una soluzione migliore \`e rappresentata dal \textbf{TTP} o \textbf{trusted 3rd party}, ossia una terza parte
\emph{fidata}, a cui gli utenti si appoggiano per comunicare.

Ogni utente deve ricordarsi una sola chiave mentre TTP gestisce la creazione e lo scambio delle chiavi condivise tra i
due utenti.

Siano $A$ e $B$ i due utenti che vogliono comunicare, il processo di scambio funziona in questo modo:
\begin{enumerate}
	\item $A$ e $B$ possiedono rispettivamente $k_A$ e $k_B$, due chiavi generate da loro stessi.
	\item $A$ comunica a TTP di voler comunicare con $B$.
	\item TTP genera casualmente una chiave $k_{AB}$ che potranno usare i due utenti per quella comunicazione.
	\item TTP cifra genera due crittogrammi $c_A$ e $c_B$ in questo modo
	      \[
		      \begin{matrix}
			      c_A & = & C(k_{AB}, k_A) \\
			      c_B & = & C(k_{AB}, k_B)
		      \end{matrix}
	      \]
	\item TTP invia $c_A$ e $c_B$ ad $A$.
	\item $A$ decifra $c_A$ con $k_A$ e invia a $c_B$ a $B$.
	\item $B$ decifra $c_B$ con $k_B$.
\end{enumerate}
Alla fine di questo processo i due utenti sono in possesso di una chiave $k_{AB}$ che potranno usare per quella
comunicazione in un cifrario simmetrico.

Le problematiche di questo sistema sono due:
\begin{itemize}
	\item TTP deve essere sempre online.
	\item TTP conosce tutte le chiavi.
\end{itemize}
\`E un approccio utilizzabile solo in un sistema ristretto come un'universit\`a o un'azienda.

\section{Chiave pubblica}
In questo tipo di cifratura si vuole implementare un meccanismo che permette a chiunque di inviare messaggi cifrati a
un certo utente ma permettere solo a quell'utente di decifrarli.

Le operazioni di cifratura e decifrazione sono pubbliche e utilizzano due chiavi diverse:
\begin{itemize}
	\item \textbf{Chiave pubblica}: \`e nota a tutti.
	\item \textbf{Chiave private}: nota solo al destinatario.
\end{itemize}
Questa coppia di chiavi \`e generata dall'utente in veste di destinatario, il rende nota la sua chiave pubblica e
mantiene segreta la sua chiave privata.

Se volessimo inviare un messaggio all'utente $i$ si dovrebbe cifrare il messaggio con la sua chiave pubblica. L'utente
$i$ decifra il crittogramma con la sua chiave privata.

In questo sistema l'unica cosa non nota a tutti \`e la chiave privata del destinatario. Le funzioni di cifratura e
decifrazione e la chiave pubblica sono note a qualsiasi utente.

I cifrari a chiave pubblica hanno due principali vantaggi
\begin{itemize}
	\item Se ci sono $n$ utenti nel sistema, il numero complessivo di chiavi pubbliche e private \`e $2n$ anzich\'e
	      $\frac{n(n-1)}{2}$
	\item Non \`e richiesto alcuno scambio segreto di chiavi.
\end{itemize}
ma possiede anche altri due principali svantaggi
\begin{itemize}
	\item Sono molto pi\`u lenti dei cifrari simmetrici.
	\item Sono esposti ad attacchi di tipo \emph{chosen plain text}.
\end{itemize}

\subsection{Attacchi chosen plain text}
Un crittoanalista quando effettua un'attacco di questo tipo
\begin{enumerate}
	\item Si procura un po' di messaggi in chiaro.
	\item Li cifra con la funzione pubblica $C$ e con la chiave pubblica $k_{\text{pub}}$ del destinatario.
	\item Confronta infine i crittogrammi in suo possesso con i crittogrammi che passano sul canale.
\end{enumerate}
Un attacco di questo tipo \`e molto pericoloso nel caso in cui il crittoanalista sospetta che un certo messaggio debba
transitare sul canale.

Ecco perch\'e questi cifrari non sono usati per comunicare ma solo per scambiarsi la chiave di un cifrario simmetrico
(AES).

In questo modo risolviamo in un colpo solo tutti i problemi elencati in precedenza:
\begin{itemize}
	\item Il processo \`e "lento" solo per lo scambio della chiave (256 bit) ma la comunicazione viene fatta con un
	      cifrario simmetrico molto veloce.
	\item L'attacco di tipo \emph{chosen plain text} diventa inutile dato che la chiave \`e una sequenza di bit casuale.
\end{itemize}

\subsection{Requisiti}
Perch\'e la cifratura a chiave pubblica devono essere soddisfatti alcuni requisiti.
\begin{itemize}
	\item Il procedimento di cifratura e decifrazione devono essere implementati correttamente. Il destinatario deve
	      essere in grado di decifrare qualsiasi messaggio con la propria chiave privata.
	      \[ D(C(m, k_{\text{pub}}), k_{\text{priv}}) = m \]
	\item Efficienza e sicurezza del sistema:
	      \begin{itemize}
		      \item La coppia di chiavi \`e \emph{facile} da generare e deve risultare praticamente impossibile che due
		            utenti scelgano la stessa chiave.
		      \item Dati $m$ e $k_{\text{pub}}$ \`e \emph{facile} per il mittente produrre il crittogramma.
		      \item Dati $c$ e $k_{\text{priv}}$ \`e \emph{facile} per il destinatario produrre il messaggio originale.
		      \item Pur conoscendo la chiave pubblica e le funzioni di cifratura e decifrazione deve essere
		            \emph{difficile} per il crittoanalista risalire al messaggio in chiaro.
	      \end{itemize}
\end{itemize}
La soluzione risiede nel trovare una funzione di tipo \textbf{one-way trap-door}, ovvero, una funzione facile da
calcolare e difficile da invertire a meno che non si conosca la chiave privata.

\section{RSA}
Questo cifrario usa l'algebra modulare e si basa sulla moltiplicazione di due numeri primi $p$ e $q$ poich\'e calcolare
\[ n = p \cdot q \]
richiede tempo quadratico nella lunghezza della loro rappresentazione ma, ricostruire $p$ e $q$ a partire da $n$
richiede tempo esponenziale se $p$ e $q$ sono primi.

Se si conosce tuttavia uno dei due fattori, risalire all'altro \`e facile (basta fare una divisione).

\subsection{Generazione delle chiavi}
Per la generazione delle due chiavi, il destinatario deve
\begin{enumerate}
	\item Scegliere due numeri primi $p$ e $q$ molto grandi, dove per "molto grandi" intendiamo tali che $p \cdot q$
	      sia un numero di circa 2000 bit per una protezione fino al 2030 o di circa 3000 bit se vogliamo una
	      protezione oltre il 2030.

	      Per farlo dobbiamo generare numeri di circa 1500 bit ed effettuare il test di Miller-Rabin per la
	      primalit\`a finch\'e non otteniamo due numeri primi (tempo polinomiale).
	\item Calcolare
	      \[ n = p \cdot q \]
	      e la relativa funzione di Eulero
	      \[ \phi(n) = (p - 1)(q - 1) \]
	      il tutto in tempo polinomiale.
	\item Scegliere un intero $e$ tale che
	      \[ e < \phi(n) \quad \wedge \quad (e, \phi(n)) = 1 \]
	\item Calcolare con l'algoritmo di Euclide esteso
	      \[ d = e^{-1} \mod{\phi(n)} \]
	      ossia l'inverso di $e$ modulo $\phi(n)$.
\end{enumerate}

\subsection{Cifratura e decifrazione}
Sia $m$ un messaggio scritto come una sequenza binaria e trattato come un intero tale che
\[ m < n \]
Il valore decimale di $m$ deve essere strettamente minore di $n$, se cos\`i non fosse dobbiamo dividere $m$ in
blocchi di $b = \log_2 n$ bit

Questo requisito \`e dovuto al fatto che tutte le operazioni sono fatte $\mod{n}$ e quindi
\[ m \geq n \]
implicherebbe
\[ m = m \mod{n} \]
Si avrebbe quindi una funzione non iniettiva che mappa messaggi diversi nello stesso crittogramma.

Nella pratica si fissa il valore di $b$ in modo da dare un limite inferiore a $n$, costringendo cos\`i l'utente ad usare
chiavi lunghe
\[ m < 2^b < n \]

Per la \textbf{cifratura} si utilizza la chiave pubblica ed \`e definita come segue
\[ c = m^e \mod{n} \]
Per la \textbf{decifrazione} si utilizza la chiave privata del destinatario ed \`e definita in questo modo
\[ m = c^d \mod{n} \]
Sia cifratura che decifrazione hanno costo polinomiale con l'algoritmo di \emph{esponenziazione veloce}.

\begin{example}
	Consideriamo due numeri primi $p = 5$ e $q = 11$, otteniamo quindi
	\[ n = p \cdot q = 55 \]
	Calcoliamo la funzione di Eulero di $n$
	\[ \phi(n) = (p - 1) (q - 1) = 40 \]
	Scegliamo ora un numero minore di $\phi(n)$ e coprimo con esso, per esempio
	\[ e = 7 \]
	La coppia $\langle n, e \rangle$ sar\`a la nostra chiave pubblica. Calcoliamo ora la chiave privata $d$ con
	l'algoritmo di Euclide esteso
	\[ d = 7^{-1} \mod{40} = 23 \]
	Adesso non ci rimane che cifrare o decifrare con le funzioni di cifratura e decifrazione descritte sopra
	\[
		\begin{matrix}
			c = m^7 \mod{55} \\
			m = c^{23} \mod{55}
		\end{matrix}
	\]
\end{example}

\subsection{Correttezza}
Dimostriamo che il cifrario \`e corretto.

\begin{proof}
	Per dimostrare la correttezza del cifrario dobbiamo dimostrare che
	\[ D(C(m, k_\text{pub}), k_\text{priv}) = m \]
	per farlo dobbiamo dimostrare che
	\[ {\underbrace{(m^e \mod{n})}_c}^d \mod{n} = m \]
	che possiamo riscrivere come
	\[ m^{ed} \mod{n} = m \]
	Si procede per casi
	\begin{enumerate}
		\item Nel primo caso in cui supponiamo $m$ e $n$ coprimi quindi $(m, n) = 1$. Dato che $m$ e $n$ sono coprimi
		      vale il teorema di Eulero
		      \[ m^{\phi(n)} \equiv 1 \mod{n} \]
		      Partendo dalla definizione di inverso facciamo anche un'altra considerazione: dato che $e$ e $d$ sono
		      l'uno l'inverso dell'altro modulo $\phi(n)$ vale
		      \[ ed \equiv 1 \mod{\phi(n)} \]
		      che equivale a dire che
		      \[ ed = r \cdot \phi(n) + 1 \]
		      con $r \in \mathbb{N}$. Possiamo quindi scrivere l'ipotesi come
		      \[ m^{ed} \mod{n} = m^{r \phi(n) + 1} \mod{n} \]
		      Usando le propriet\`a delle potenze possiamo scrivere
		      \[ m \cdot (m^{\phi(n)})^r \mod{n} \]
		      Per il teorema di Eulero questo equivale a
		      \[ m \cdot 1^r \mod{n} = m \mod{n} = m\]
		      dato che $m < n$.
		\item Nel secondo caso $(n, m) \neq 1$. Il massimo comun divisore tra $n$ ed $m$ deve essere o $p$ o $q$ e
		      vale che
		      \[ p \mid m \quad \text{oppure} \quad q \mid m \]
		      ma non entrambi possono essere divisori di $m$ perch\'e altrimenti $m \geq n$. Supponiamo che $p \mid m$
		      quindi $q \nmid m$, questo ci dice che
		      \[ m \equiv 0 \mod{p} \quad \Rightarrow \quad m^r \equiv 0 \mod{p} \]
		      per ogni $r \in \mathbb{N}$. Vale quindi che
		      \[ m^r - m \equiv 0 \mod{p} \]
		      Se prendiamo $r = ed$ otteniamo
		      \[ m^{ed} - m \equiv 0 \mod{p} \]

		      Consideriamo ora $q$, che ricordiamo, non divide $m$ e consideriamo
		      \[ m^{ed} \mod{q} \]
		      Questa equazione pu\`o essere riscritta come
		      \[ m^{k \phi(n) + 1} \mod{q} \]
		      ma come sappiamo $\phi(n)$ si pu\`o riscrivere come $(p - 1)(q - 1)$
		      \[ m \cdot m^{k (p - 1)(q - 1)} \mod{q} \]
		      come prima, per le propriet\`a delle potenze, possiamo scrivere
		      \[ m \cdot (m^{(q - 1)})^{k (p - 1)} \mod{q} \]
		      dato che $q$ \`e un numero primo possiamo riscrivere l'equazione in questo modo
		      \[ m \cdot (m^{\phi(q)})^{k (p - 1)} \mod{q} \]
		      Usiamo il teorema di Eulero
		      \[ m \cdot 1^{k (p - 1)} \mod{q} = m \mod{q} \]
		      quindi
		      \[ m^{ed} \mod{q} = m \mod{q} \]
		      dunque vale
		      \[ m^{ed} - m \equiv 0 \mod{q} \]

		      Possiamo quindi affermare che $m^{ed} - m$ \`e divisibile sia per $p$ che per $q$, quindi vale
		      \[ m^{ed} - m \equiv 0 \mod{n} \]
		      riscriviamo l'equazione come
		      \[ m^{ed} \mod{n} = m \mod{n} \]
		      ma dato che $m < n$ vale
		      \[ m \mod{n} = m \]
		      Questo dimostra la correttezza anche quando messaggio e modulo non sono coprimi.
	\end{enumerate}
\end{proof}

\subsection{Sicurezza}
La \textbf{sicurezza} del cifrario \`e molto legata alla difficolt\`a nel fattorizzare un numero arbitrario molto
grande.

Riuscire a fattorizzare in tempo polinomiale \`e condizione sufficente per riuscire a forzare l'RSA ma non ci sono
dimostrazione del fatto che sia anche condizione necessaria.

Dato che il crittogramma $c$ \`e ottenuto tramite
\[ c = m^e \mod{n} \]
si potrebbe pensare di calcolare una radice
\[ m = \sqrt[e]{c} \mod{n} \]
ma dato che stiamo lavorando nell'algebra modulare e $n$ \`e un numero composto, l'estrazione della radice \`e un
problema \emph{difficile} almeno quanto la fattorizzazione.

\`E dunque pi\`u conveniente fattorizzare e compiere un attacco all'intero sistema piuttosto che sul singolo
crittogramma.

Anche calcolare $\phi(n)$ direttamente da $n$ \`e un problema \emph{difficile} quanto la fattorizzazione.

Provare a ricavare $d$ direttamente da $n$ ed $e$ \`e un problema che \emph{sembra} costoso quanto la
fattorizzazione.

Il problema della fattorizzazione rimane \emph{difficile} ma non pi\`u come un tempo. Ci sono ad oggi algoritmi
pi\`u raffinati che richiedono un numero di operazioni \textbf{subesponenziale}.

Parliamo dell'algoritmo GNFS, il quale, dato un intero $n$ rappresentato con
\[ b = \lceil \log_2 n \rceil + 1 \]
bit, richiede un numero di operazioni dell'ordine di $O(2^{\sqrt{b \log b}})$.

Ad oggi, tramite l'algoritmo GNFS, si riescono a fattorizzare semiprimi di 768 bit.

\subsubsection{Vincoli sui parametri}
I due parametri $p$ e $q$ devono essere scelti in base ad alcuni propriet\`a, senza le quali si riuscirebbe
facilmente forzare il cifrario:
\begin{itemize}
	\item Devono essere numeri di almeno 1024 bit per resistere agli attacchi a forza bruta.
	\item Sia $p-1$ che $q-1$ devono contenere un fattore primo molto grande (altrimenti $n$ si fattorizza
	      velocemente).
	\item $(p-1, q-1)$ deve essere piccolo. Conviene scegliere $p$ e $q$ tali che $\frac{p-1}{2}$ e $\frac{q-1}{2}$
	      siano coprimi.
	\item Non si deve riusare uno dei due primi per altre sessioni di comunicazione.
	      \[
		      \begin{matrix}
			      n_1 = p \cdot q_1 \\
			      n_2 = p \cdot q_2
		      \end{matrix}
		      \quad \Rightarrow \quad
		      p = (n_1, n_2)
	      \]
	\item La differenza tra $p$ e $q$ deve essere grande. Se cos\`i non fosse $p^2$ e $q^2$ sarebbero circa $n$ e
	      quindi $\sqrt{n}$ sar\`a vicino ai numeri primi.

	      Si effettua quindi un attacco a forza bruta che cerca i fattori vicini a $\sqrt{n}$.
\end{itemize}

Anche la scelta di $e$ e $d$ deve rispettare alcune propriet\`a. \`E vero che valori di $e$ e $d$ bassi accelerano
la cifraura e la decifrazione ma ci fa andare incontro ad altri problemi
\begin{itemize}
	\item Se $d$ \`e piccolo l'attacco a forza bruta diventa un'opzione valida.
	\item Se $m$ ed $e$ sono cos\`i piccoli che
	      \[ m^e < n \]
	      allora risulta facile trovare la radice $e$-esima di $c$ poich\'e non interviene la riduzione in modulo.
\end{itemize}
Ecco perch\'e, per avere garanzie sulla sicurezza, \`e importante scegliere anche $e$ e $d$ opportunamente grandi.