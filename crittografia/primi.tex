\chapter{Primalit\`a}
Iniziamo ora a parlare di \textbf{primalit\`a} e di come costruire algoritmi efficienti per effettuare il
\textbf{test di primalit\`a}, ossia algoritmi in grado di dirci se un numero \`e primo o no.

Iniziamo con un algoritmo semplice ma che come vedremo risulter\`a molto inefficiente.
\begin{lstlisting}[style=pseudo-style]
Primo(n)
	for(i = 2; i <= sqrt(n); i++)
		if n % i == 0 then
			return false;
	
	return true;
\end{lstlisting}
Come possiamo facilmente constatare, l'algoritmo
\begin{enumerate}
	\item Controlla se uno dei numeri da 2 a $\sqrt{n}$ divide $n$. Si parte da 2 dato che la divisione per 0 \`e in
	      generale indefinita o comunque tende all'infinito e tutti i numeri sono divisibili per 1.

	      Ci si ferma a $\sqrt{n}$ dato che un numero, se composto, possiede sicuramente un divisore minore della sua
	      radice.
	\item Se ne trova uno che divide $n$ allora ritorna \verb|false|.
	\item Se non ne trova nessuno ritorna \verb|true|.
\end{enumerate}
Un'analisi poco attenta potrebbe indurci a pensare che il costo di questo algoritmo sia $O(\sqrt{n})$ dato che faccio al
pi\`u $\sqrt{n}$ iterazioni. Questo \`e in parte vero ma dobbiamo considerare la dimensione dell'istanza di input, la
sua rappresentazione e il costo della divisione.

L'istanza di input, ossia $n$, richiede $\theta(\log_2 n)$ bit per essere rappresentata mentre la divisione \`e, in
generale, un'operazione quadratica nel numero di cifre. Tutto questo fa salire la complessit\`a a
\[ O(\sqrt{n} \cdot \log^2 n) \]
Ma non \`e finita qui: come abbiamo detto, $n$, necessita di $\theta(\log_2 n)$ bit per essere rappresentato, dunque $n$
si pu\`o scrivere come $2^{\log n}$ e questo fa diventare la complessit\`a
\[ O(2^\frac{\log n}{2} \cdot \log^2 n) \]
Come possiamo vedere, un algoritmo all'apparenza polinomiale \`e in realt\`a un algoritmo di costo esponenziale nella
dimensione dell'input. Si tratta di un algoritmo \textbf{pseudopolinomiale}.