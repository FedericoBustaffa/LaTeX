\chapter{Protocolli}
In questo capitolo andremo a trattare i protocolli di sicurezza tra i quali distingueremo
\begin{itemize}
	\item \textbf{Identificazione}: un sistema di elaborazione ha bisogno di accertarsi dell'\textbf{identit\`a}
	      di un utente che vuole accedere ai suoi servizi.
	\item \textbf{Autenticazione}: il destinatario di un messaggio deve essere in grado di accertare
	      l'\textbf{identit\`a del mittente} e l'\textbf{integrit\`a del crittogramma} ricevuto.
	\item \textbf{Firma digitale}: la firma digitale si pone tre obbiettivi:
	      \begin{itemize}
		      \item Il mittente non deve poter \textbf{negare l'invio} di un messaggio.
		      \item Il destinatario deve essere in grado di \textbf{autenticare} il messaggio.
		      \item Il destinatario non deve poter sostenere di aver ricevuto un messaggio diverso da quello inviato
		            dal mittente.
	      \end{itemize}
\end{itemize}
Come si pu\`o notare, ognuna di queste funzionalit\`a, estende l'altra
\begin{itemize}
	\item L'autenticazione garantisce l'identificazione.
	\item La firma digitale garantisce l'autenticazione.
\end{itemize}
Ognuna di queste funzionalit\`a ha il compito di proteggere le comunicazioni da attacchi attivi, come per esempio
gli attacchi \emph{man in the middle}.

\section{Funzioni hash}
Per l'implementazione di queste funzionalit\`a faremo ricorso alla \textbf{funzioni hash}. Una funzione hash
\[ f : X \rightarrow Y \]
\`e una funzione tale che
\[ n = |X| >> m = |Y| \]
ossia, \`e tale se, definito il dominio $X$, il codominio $Y$ della funzione \`e molto pi\`u piccolo.

Inoltre, una funzione hash, ha molti elementi del dominio che vengono mappati nella stessa immagine del codominio.
Questo ci permette di \emph{partizionare} il dominio in sottoinsiemi
\[ X = X_1 \cup X_2 \cup \dots \cup X_m \]
tali che ogni elemento del sottoinsieme \`e mappato, dalla funzione hash, nella stessa immagine del codominio
\[ \forall i, \quad \forall x \in X_i \quad \quad f(x) = y \]
Una funzione hash \`e buona se la cardinalit\`a di ogni sottoinsieme sia circa la stessa.

\subsection{Funzioni hash one-way}
Le funzioni hash usate in crittografia devono soddisfare tre requisiti principali
\begin{itemize}
	\item Per ogni $x \in X$ deve essere \emph{facile} calcolare
	      \[ y = f(x) \]
	\item \textbf{One-way}: per la maggior parte degli $y \in Y$ deve essere \emph{difficile} determinare $x \in X$
	      tale che
	      \[ f(x) = y \]
	\item \textbf{Claw-free}: deve essere \emph{difficile} determinare una coppia $x_1, x_2 \in X$ tali che
	      \[ f(x_1, x_2) \]
\end{itemize}

\subsection{Funzione hash SHA-1}
Una delle funzioni, storicamente usata in crittografia, \`e \textbf{SHA-1}, la quale opera su sequenze lunghe fino
a $2^{64} - 1$ bit e produce immagini di 160 bit.

In particolare opera su blocchi di 160 bit, contenuti in un buffer di 5 registri da 32 bit ciascuno, in cui sono
caricati inizialmente dei valori pubblici.

Il messaggio viene concatenato con una sequenza di \emph{padding} che rende la sua lunghezza un multiplo di 512 bit.

Il contenuto dei registri varia nel corso dei cicli successivi in cui questi valori si combinano tra loro e con
blocchi di 32 bit provenienti dal messaggio.

La funzione sfrutta shift ciclici e una componente non lineare che varia per riuscire ad ottenere il valore hash per
ciascun messaggio in input.

\section{Identificazione}
Vediamo ora come viene applicato il protocollo di \textbf{identificazione} sia nel caso in cui ci trovassimo su un
canale sicuro sia nel caso in cui ci trovassimo su un canale insicuro.

\subsection{Canale sicuro}
Prendiamo per esempio la situazione in cui un utente voglia accedere ai propri file personali memorizzati su un
calcolatore ad accesso riservato ai membri della sua organizzazione.
\begin{enumerate}
	\item L'utente invia in chiaro nome utente e password.
	\item Dato che il canale \`e sicuro, un attacco pu\`o essere sferrato solo da un utente locale al sistema o da
	      un hacker.
\end{enumerate}
Il meccanismo di identifiaczione dovrebbe per\`o prevedere una \textbf{cifratura} della password tramite funzioni hash
one-way anche su canali sicuri.

Dobbiamo distinguere due casi: quando l'utente si registra e quando l'utente effettua tutti gli accessi successivi.

\subsubsection{Registrazione}
Possiamo associare la fase di registrazione alla fase di cifratura con una funzione hash one-way $h$:
\begin{enumerate}
	\item L'utente $u$ si registra fornendo per la prima volta la password $p$.
	\item Il sistema associa a $p$ due sequenze binarie che memorizza nel file delle password al posto di $p$.
	      \begin{itemize}
		      \item Un \textbf{seme} casuale $s$ prodotto da un generatore.
		      \item Il \textbf{valore hash} della concatenazione tra $p$ ed $s$.
		            \[ q = h(p s) \]
	      \end{itemize}
\end{enumerate}
Quello che quindi viene salvato dal sistema \`e l'\textbf{immagine hash} della password concatenata ad un seme casuale
e non la password in chiaro.

\subsubsection{Accesso}
In fase di accesso il sistema compie i seguenti passaggi
\begin{enumerate}
	\item Recupera $s$ dal file delle password.
	\item Concatena $s$ con la password $p$ fornita da $u$.
	\item Calcola il valore hash della sequenza $p s$.
	\item Se $q = h(p s)$ l'identificazione ha successo.
\end{enumerate}
Avere accesso al file delle password non fornisce informazioni interessanti perch\'e \`e computazionalmente difficile
ricavare la password dalla sua immagine hash.

\subsection{Canale insicuro}
Nel caso di canale insicuro non si pu\`o inviare la password in chiaro e dunque andremo a lavorare con sistemi a
chiave pubblica per l'invio della password.

In realt\`a un sistema non dovrebbe mai poter maneggiare password in chiaro ma solo una loro immagine hash.

Supponiamo che l'utente $u$ voglia accedere ai servizi forniti da un certo sistema $s$ e per farlo \`e necessario
che si identifichi.

Supponiamo che il sistema adotti un cifrario a chiave pubblica (per esempio l'RSA) per lo scambio sicuro dei dati
dell'utente. L'utente dispone quindi di una chiave pubblica $\langle e, n \rangle$ e di una chiave privata $d$.

Quello che avviene all'atto pratico \`e questo:
\begin{enumerate}
	\item $s$ genera un numero casuale $r < n$ e lo invia in chiaro a $u$.
	\item $u$ calcola
	      \[ f = r^d \mod{n} \]
	      che rappresenta la \textbf{firma} di $u$ su $s$ e lo invia a $s$.
	\item $s$ verifica che
	      \[ f^e \mod{n} = r \]
	      se l'uguaglianza \`e soddisfatta, l'identificazione ha successo.
\end{enumerate}
Come possiamo notare, le operazioni di cifratura e decifrazione sono invertite rispetto all'impiego standard dell'RSA
ed \`e possibile farlo dato che sono commutative
\[ (x^e \mod{n})^d \mod{n} = (x^d \mod{n})^e \mod{n} \]
Chiariamo inoltre che solo $u$ pu\`o produrre $f$ dato che \`e l'unico che possiede il valore $d$.

Se il passo 3 va a buon fine, il sistema ha la garanzia che l'utente che ha richiesto l'identificazione sia
effettivamente $u$, anche se il canale \`e insicuro.

Il protocollo funziona bene a patto che il sistema sia onesto. Dato che \`e il sistema che fornisce $r$, se $r$ \`e
effettivamente un valore casuale allora tutto va a buon fine, se invece $r$ \`e un dato con particolari propriet\`a
utili a ricavare la chiave privata di $u$.

\section{Autenticazione}
L'autenticazione riguarda il messaggio e si occupa di accertare l'identit\`a del mittente e l'integrit\`a del
messaggio.

\subsection{Canale insicuro}
Per questo protocollo, su canale insicuro, useremo un sistema basato su cifrari simmetrici in cui mittente e
destinatario devono quindi accordarsi su una chiave segreta $k$.

Nella pratica il mittente
\begin{enumerate}
	\item Allega al messaggio un \textbf{MAC} (Message Authentication Code) $A(m, k)$, allo scopo di garantire la
	      provenienza e l'integrit\`a del messaggio.
	\item A questo punto ha due opzioni
	      \begin{itemize}
		      \item Invia la coppia $\langle m, A(m, k) \rangle$ in chiaro.
		      \item Cifra $m$ e spedisce $\langle C(m, k'), A(m, k) \rangle$ dove $C$ \`e una funzione di cifratura
		            e $k'$ la chiave pubblica o la chiave simmetrica segreta del cifrario scelto.
	      \end{itemize}
\end{enumerate}

Il destinatario invece
\begin{enumerate}
	\item Riceve il messaggio (se cifrato lo decifra).
	\item Dato che conosce $A$ e $k$ calcola a sua volta il MAC.
	\item Confronta il MAC calcolato con il MAC ricevuto.
\end{enumerate}
Se la verifica ha successo il messaggio \`e autenticato altrimenti lo si scarta.

\subsubsection{MAC}
Il MAC \`e un'immagine breve del messaggio che pu\`o essere generata solo da un mittente conosciuto dal destinatario
e pu\`o essere calcolato con cifrari asimettrici, simmetrici o funzioni hash one-way.

Quest'ultima opzione implementativa \`e la pi\`u frequente
\[ A(m, k) = h(m k) \]
dato che il calcolo di una funzione hash \`e molto veloce per chi sta cifrando ma computazionalmente molto dispendioso
per un crittoanalista, che, anche disponendo di $h$ e $m$ non \`e comunque in grado di risalire a $k$ in tempo
polinomiale dato che $k$ viaggia all'interno di un MAC e quindi si dovrebbe invertire la funzione hash (costo
esponenziale).

Il crittoanalista non pu\`o nemmeno sostituire (facilmente) il messaggio $m$ con un altro messaggio $m'$ perch\'e
dovrebbe allegare a $m'$ il MAC $A(m', k)$ che pu\`o produrre solo conoscendo $k$.

\section{Firma digitale}
Questo protocollo cerca di portare tutte le propriet\`a di una \textbf{firma manuale} (con carta e penna) in ambito
tecnologico. Una firma manuale infatti
\begin{itemize}
	\item \`E autentica e non falsificabile.
	\item Non \`e riutilizzabile.
	\item Non pu\`o essere ripudiata.
\end{itemize}
Anche il documento firmato deve essere \textbf{inalterabile}.

Come vedremo, una \textbf{firma digitale}
\begin{itemize}
	\item Non pu\`o consistere nella digitalizzazione di un documento scritto firmato manualmente perch\'e si
	      potrebbe facilmente contraffare.
	\item Deve avere una forma che dipenda dal documento su cui viene apposta, per essere inscindibile da
	      quest'ultimo.
	\item Pu\`o essere generata sia tramite cifrari simmetrici che asimmetrici.
\end{itemize}

\subsection{Protocollo 1: Diffie Hellman}
In questo protocollo il messaggio $m$ \`e in chiaro e firmato.

Supponiamo che un utente $u$, in possesso di una coppia di chiavi $\langle k_\text{pub}, k_\text{priv} \rangle$ e
che ha a disposizione una funzione $C$ di cifratura e una funzione $D$ di decifrazione (commutative), voglia firmare
$m$ e inviarlo a $v$.

Per firmare $m$, l'utente $u$
\begin{enumerate}
	\item Genera la firma $f$ per $m$ calcolando
	      \[ f = D(m, k_\text{priv}) \]
	\item $u$ invia all'utente $v$ la tripla $\langle u, m, f \rangle$.
\end{enumerate}
L'utente $v$
\begin{enumerate}
	\item Riceve $\langle u, m, f \rangle$.
	\item Verifica l'autenticit\`a della firma calcolando e controllando che
	      \[ m = C(f, k_\text{pub}) \]
\end{enumerate}
Se la verifica va a buon fine allora $v$ accetta la firma.

\subsubsection{Limiti}
Questo protocollo ha il grosso limite di non riuscire a proteggere il messaggio in lettura, infatti anche se
inviassimo un crittogramma $c$ di $m$, sarebbe il risultato della cifratura di $m$ con la chiave pubblica.

Possiede tuttavia tutti i requisiti di una firma manuale
\begin{itemize}
	\item La chiave $k_\text{priv}$ \`e nota solo a $u$ e per ottenerla si fa un numero esponenziale di operazioni.
	\item Se $m$ venisse alterato dal crittoanalista non ci sarebbe pi\`u consistenza tra $m$ e $f$ e la verifica
	      fallirebbe.
	\item Poich\'e solo $u$ pu\`o aver prodotto $f$ non pu\`o ripudiarla.
	\item Dato che la firma \`e un'immagine di $m$ non \`e riutilizzabile su un altro messaggio $m'$.
\end{itemize}

\subsection{Protocollo 2}
Questo protocollo si propone di risolvere il problema del precedente relativo all'impossibilit\`a di proteggere il
messaggio.

L'utente $u$
\begin{enumerate}
	\item Genera la firma $f$ per $m$ calcolando
	      \[ f = D(m, k_\text{priv}) \]
	\item Cifra la firma calcolando
	      \[ c = C(f, k) \]
	      dove $k$ pu\`o essere la chiave pubblica del destinatario oppure una chiave simmetrica segreta.
	\item Invia la coppia $\langle u, c \rangle$ a $v$.
\end{enumerate}
L'utente $v$
\begin{enumerate}
	\item Riceve $\langle u, c \rangle$.
	\item Ricava $f$ calcolando
	      \[ f = D(c, k) \]
	      con $k$ che pu\`o essere la sua chiave privata o una chiave simmetrica.
	\item Cifra $f$ con la chiave pubblica del mittente ottenendo il messaggio $m$
	      \[ m = C(f, k_\text{pub}) \]
\end{enumerate}
Se il messaggio \`e significativo l'identit\`a di $u$ \`e attestata altrimenti si butta via il messaggio.

\subsubsection{Algoritmo con RSA}
In questo caso abbiamo due coppie di chiavi
\begin{gather*}
	d_u, \quad \langle e_u, n_u \rangle \\
	d_v, \quad \langle e_v, n_v \rangle
\end{gather*}
La coppia del mittente \`e usata per produrre la firma e verificarla mentre la coppia del destinatario per decifrare
il crittogramma.

Supponiamo che $u$ sia il mittente e $v$ il destinatario, l'utente $u$
\begin{enumerate}
	\item Genera la firma del messaggio $m$ calcolando
	      \[ f = m^{d_u} \mod{n_u} \]
	\item Cifra $f$ con la chiave pubblica di $v$ calcolando
	      \[ c = f^{e_v} \mod{n_v} \]
	\item Invia la coppia $\langle u, c \rangle$ a $v$.
\end{enumerate}
L'utente $v$
\begin{enumerate}
	\item Riceve la coppia $\langle u, c \rangle$.
	\item Decifra $c$ calcolando
	      \[ f = c^{d_v} \mod{n_v} \]
	\item Decifra $f$ con la chiave pubblica di $u$
	      \[ m = f^{e_u} \mod{n_u} \]
\end{enumerate}
Se $m$ \`e significativo allora l'identit\`a del mittente \`e attestata.

Affinch\'e il procedimento venga effettuato correttamente \`e necessario che
\[ f < n_v \]
e perch\'e questo accada c'\`e bisogno che
\[ n_u \leq n_v \]
Questo impedisce a $v$ di inviare messaggi firmati e cifrati da $u$.

Di solito ogni utente ha due coppie di chiavi diverse, una per la firma e una per la cifratura, tali che le chiavi
per la firma siano per esempio minori di un certo valore $H$ e quelle di cifratura siano invece maggiori. Il valore
$H$ \`e un valore molto grande su cui i due utenti si devono accordare.

\subsubsection{Attacco}
Un crittoanalista potrebbe procurarsi la firma di un utente su messaggi apparentemente privi di senso.

Prendiamo uno scenario in cui un crittoanalista $x$ si procura la firma dell'utente da messaggi privi di senso
per l'utente.

Supponiamo che
\begin{itemize}
	\item Il destinatario $v$ di un messaggio invii sempre una risposta $ack$ al mittente $u$ ogni volta che
	      riceve un messaggio (prima della verifica della firma).
	\item Il segnale di $ack$ sia il crittogramma della firma di $v$ su $m$.
\end{itemize}
In queste condizioni, un attacco attivo, pu\`o avere successo se
\begin{enumerate}
	\item $x$ intercetta il crittogramma $c$ firmato inviato da $u$ a $v$, lo rimuove dal canale e lo rispedisce a
	      $v$, facendogli credere che $c$ sia stato inviato da lui.
	\item $v$ spedisce automaticamente a $x$ un ack.
	\item $x$ usa l'ack ricevuto per risalire al messaggio originale applicando le funzioni del cifrario con le
	      chiavi pubbliche di $u$ e $v$.
\end{enumerate}
Per risalire a $m$, il crittoanalista compie dei passaggi algebrici che avranno complessivamente costo polinomiale.

Prima di tutto, il fatto che $u$ abbia inviato il crittogramma $c$ a $v$, significa che
\begin{gather*}
	c = C(f, k_{v [\text{pub}]}) \\
	f = D(m, k_{u [\text{priv}]})
\end{gather*}
A questo punto, dopo che $x$ ha intercettato $c$ e l'ha rispedito a $v$, l'utente $v$ decifra $c$ ottenendo
\[ f = D(c, k_{v [\text{priv}]}) \]
e verifica la firma con la chiave pubblica di $x$ ottenendo un messaggio
\[ m' = C(f, k_{x [\text{pub}]}) \]
Il messaggio $m'$, molto probabilmente, non \`e significativo ma l'ack $c'$ \`e gi\`a stato inviato in automatico
calcolando
\begin{gather*}
	f' = D(m', k_{v [\text{priv}]}) \\
	c' = C(f', k_{x [\text{pub}]})
\end{gather*}
A questo punto $x$ ha tutto ci\`o che serve:
\begin{enumerate}
	\item Decifra $c'$ e trova $f'$
	      \[ f' = D(c', k_{x [\text{priv}]}) = D(C(f', k_{x [\text{pub}]}), k_{x [\text{priv}]}) \]
	\item Verifica la firma $f'$ e trova $m'$ usando la chiave pubblica di $v$
	      \[ m' = C(f', k_{v [\text{pub}]}) = C(D(m', k_{v [\text{priv}]}), k_{v [\text{pub}]}) \]
	\item Da $m'$ ricava la firma $f$
	      \[ f = D(m', k_{x [\text{priv}]}) = D(C(f, k_{x [\text{pub}]}), k_{x [\text{priv}]}) \]
	\item Verifica $f$ con la chiave pubblica di $u$ e trova $m$
	      \[ m = C(f, k_{u [\text{pub}]}) = C(D(m, k_{u [\text{priv}]}), k_{u [\text{pub}]}) \]
\end{enumerate}
Come possiamo vedere si usano sempre le funzioni di cifratura e decifrazione che, come sappiamo, hanno sempre costo
polinomiale e quindi anche l'attacco ha costo complessivamente polinomiale.

Per proteggersi da questo attacco non si devono inviare ack automatici, almeno finch\'e non si \`e concluso la fase
di verifica e si deve sempre firmare un'immagine hash del messaggio.

\subsection{Protocollo 3}
Questo protocollo si propone di risolvere anche i problemi presentati del secondo. In questo caso il messaggio
$m$ \`e cifrato e firmato con una funzione hash.

Il mittente $u$
\begin{enumerate}
	\item Calcola l'hash del messaggio $h(m)$ e genera la firma calcolando
	      \[ f = D(h(m), k_{u [\text{priv}]}) \]
	\item Cifra il messaggio calcolando
	      \[ c = C(m, k_{v [\text{pub}]}) \]
	\item Invia la tripla $\langle u, c, f \rangle$ a $v$.
\end{enumerate}
Il destinatario $v$
\begin{enumerate}
	\item Riceve la tripla $\langle u, c, f \rangle$.
	\item Decifra $c$ calcolando
	      \[ m = D(c, k_{v [\text{priv}]}) \]
	\item Calcola $h(m)$.
	\item Verifica la firma calcolando e verificando che
	      \[ h(m) = C(f, k_{u [\text{pub}]}) \]
\end{enumerate}
Come per tutti i protocolli a chiave pubblica, anche questo \`e vulnerabile ad attacchi di tipo
\emph{man in the middle}.

\subsection{Certification Authority}
Un algoritmo \`e tanto robusto quanto la sicurezza delle sue chiavi ma lo scambio o la generazione della chiave \`e
un passo cruciale.

\`E proprio in questo frangente che i crittoanalisti sfruttano attacchi di tipo \emph{man in the middle} per
riuscire a forzare facilmente i sistemi crittografici.

Sono dunque nate delle infrastrutture, chiamate \textbf{certification authority}, adibite a garantire la validit\`a
delle chiavi pubbliche e a regolare il loro uso, gestendone la distribuzione.

Le CA rilasciano un \textbf{certificato digitale} che autentica l'associazione tra un utente e la sua chiave pubblica.

Un certificato digitale consiste della chiave pubblica di una lista di informazioni relative al suo proprietario,
opportunamente firmate dalla CA. Per falsificare un certificato si deve falsificare la firma delle CA.

Una CA mantiene un archivio di chiavi pubbliche sicuro, accessibile a tutti e protetto da attacchi in scrittura non
autorizzati.

La chiave pubblica della CA \`e nota a tutti gli utenti che la mantengono protetta sui propri dispositivi e la
utilizzano per verificare la firma della CA stessa sui certificati.

Le CA hanno in genere una struttura gerarchica ad albero e dunque si avvia una sorta di verifica a catena risalendo
le varie CA.

\subsubsection{Certificazione}
Supponiamo che $u$ voglia comunicare con $v$
\begin{enumerate}
	\item $u$ richiede la chiave pubblica di $v$ alla CA.
	\item La CA invia a $u$ il certificato digitale $c_v$ di $v$.
	\item Dato che $u$ conosce la chiave pubblica della CA, controlla l'autenticit\`a del certificato verificandone il
	      periodo di validit\`a e la firma della CA.
	\item $u$ estrae dal certificato la chiave pubblica di $v$ e inizia il protocollo di comunicazione.
\end{enumerate}
Gli attacchi \emph{man in the middle} sono sempre possibili ma devono essere effettuati falsificando la certificazione
ma si assume che la CA sia fidata e il suo archivio di chiavi inattaccabile.

\subsection{Protocollo 4}
Ultimo protocollo che vediamo consiste nel cifrare, firmare e certificare un messaggio $m$.

Il mittente $u$
\begin{enumerate}
	\item Si procura il certificato $\text{cert}_v$ di $v$ e verifica che sia autentico.
	\item Calcola $h(m)$ e genera la firma calcolando
	      \[ f = D(h(m), k_{u [\text{priv}]}) \]
	\item Cifra $m$ calcolando
	      \[ c = C(m, k_{v [\text{pub}]}) \]
	\item Invia la tripla $\langle \text{cert}_u, c, f \rangle$ a $v$.
\end{enumerate}
Il destinatario $v$
\begin{enumerate}
	\item Riceve la tripla $\langle \text{cert}_u, c, f \rangle$ a $v$.
	\item Verifica l'autenticit\`a di $\text{cert}_u$ con la chiave pubblica della CA che tiene in locale.
	\item Decifra $c$ con la sua chiave privata calcolando
	      \[ m = D(c, k_{v [\text{priv}]}) \]
	\item Verifica che la firma sia autentica controllando che
	      \[ h(m) = C(f, k_{u [\text{pub}]}) \]
\end{enumerate}
L'unico punto debole di questo metodo \`e rappresentato dall'uso di certificati revocati.