\chapter{Cifrari moderni}\label{moderni}
Passiamo ora ai cosiddetti \textbf{cifrari moderni} i quali si dividono in due grandi gruppi
\begin{itemize}
	\item \textbf{Cifrari a sicurezza incondizionata}: sono cifrari per uso ristretto e nascondono l'informazione con
	      certezza assoluta (anche per macchine quantistiche).
	\item \textbf{Cifrari a sicurezza computazionale}: sono cifrari adibiti alla crittografia di massa e nascondono
	      l'informazione solo se il crittoanalista ha accesso a risorse computazionali limitate (su macchine quantistiche
	      si forzano in tempo polinomiale). Anche nel caso in cui si riuscisse a dimostrare che P = NP ognuno di questi
	      cifrari crollerebbe e si potrebbe forzare in tempo polinomiale.
\end{itemize}

\section{Cifrari perfetti}
Un \textbf{cifrario perfetto} \`e tale se non si riesce ad estrapolare alcuna informazione dall'analisi del crittogramma.

Proviamo a formalizzare matematicamente quanto appena detto. Per farlo dobbiamo considerare
\begin{itemize}
	\item \textbf{MSG}: spazio dei messaggi.
	\item \textbf{CRITTO}: spazio dei crittogrammi.
	\item \textbf{M}: variabile aleatoria che descrive il comportamento del	mittente e assume i valori in MSG.
	\item \textbf{C}: variabile aleatoria che descrive la comunicazione sul canale.
\end{itemize}
Indichiamo ora con
\[ P(M = m) \]
la probabilit\`a che il mittente voglia inviare il messaggio $m \in$ MSG. Indichiamo invece con
\[ P(M = m \mid C = c) \]
la probabilit\`a condizionata che il messaggio inviato sia proprio $m$, posto che sul canale stia transitando il
crittogramma $c \in$ CRITTO. In altre parole quest'ultima espressione indica la probabilit\`a che $c$ sia $m$ cifrato.

\begin{theorem}\label{th: cifrario_perfetto}
	Un cifrario \`e \textbf{perfetto} se $\forall m \in \text{MSG}$ e $\forall c \in \text{CRITTO}$ vale che
	\[ P(M = m \mid C = c) = P(M = m) \]
\end{theorem}

\begin{example}
	Mettiamoci per un attimo in uno scenario di massimo pessimismo in cui il crittoanalista sa:
	\begin{itemize}
		\item La distribuzione di probabilit\`a con cui il mittente invia messaggi.
		\item Il cifrario utilizzato.
		\item Lo spazio delle chiavi.
	\end{itemize}
	Supponiamo inoltre che di voler inviare un messaggio $m$ con probabilit\`a
	\[ P(M = m) = p > 0 \quad \quad \text{con } 0 < p < 1 \]
	e analizziamo due casi estremi e opposti l'uno all'altro. Nel primo caso diciamo che esiste un crittogramma $c$ tale
	che
	\[ P(M = m \mid C = c) = 1 \]
	e nel secondo caso diciamo che esiste un crittogramma $c$ tale che
	\[ P(M = m \mid C = c) = 0 \]
	In entrambi i casi, vedere il crittogramma, raffina la conoscenza del crittoanalista. L'unico caso in cui il
	crittoanalista non ricava nulla dal crittogramma \`e il caso descritto dal teorema \ref{th: cifrario_perfetto}.
\end{example}

\subsection{Svantaggi}
L'estrema solidit\`a di un cifrario perfetto ha per\`o un costo in termini di numero di chiavi.

\begin{theorem}[Shannon]
	In un cifrario perfetto l'insieme delle chiavi deve essere grande almeno quanto l'insieme dei messaggi possibili.
	Dove per \textbf{messaggio possibile} indichiamo un messaggio $m \in$ MSG tale che
	\[ P(M = m) > 0 \]
	Questa \`e condizione necessaria ma non sufficiente affinch\'e il cifrario sia perfetto.
	\begin{proof}
		Dimostriamo il teorema per assurdo e andiamo ad indicare con $N_k$ il numero delle chiavi e con $N_m$ il numero
		dei messaggi possibili.

		Supponiamo per assurdo che
		\[ N_m > N_k \]
		e consideriamo ora un crittogramma $c$ che pu\`o transitare sul canale con probabilit\`a
		\[ P(C = c) > 0 \]
		Se provassimo a decifrare $c$ con una generica chiave $k_i$ otterremo un messaggio $m_i$. Facciamo per\`o
		attenzione al fatto che cifrando $c$ con una chiave $k_j$ potremmo ottenere il messaggio $m_i$, ottenibile anche
		con la chiave $k_i$.

		Indichiamo quindi con $s$ tale che
		\[ s \leq N_k \]
		il numero dei messaggi che potrebbero corrispondere al crittogramma $c$. Ma per ipotesi abbiamo che
		\[ N_k < N_m \]
		quindi
		\[ s \leq N_k < N_m \]
		Ho ottenuto che il numero dei messaggi che possono corrispondere al crittogramma $c$ \`e strettamente minore
		del numero dei messaggi possibili.

		Questo vuol dire che esiste un messaggio $m'$ appartenente allo spazio dei messaggi possibili che non pu\`o
		corrispondere a quel crittogramma.
		\[ P(M = m' \mid C = c) = 0 \]
		Giungiamo quindi all'assurdo dato che un cifrario \`e perfetto se un crittogramma pu\`o corrispondere ad uno
		qualsiasi dei messaggi possibili.
	\end{proof}
\end{theorem}

\subsection{One-Time Pad}
Come abbiamo in parte anticipato, il cifrario \textbf{One-Time Pad} altro non \`e che un cifrario di Vigen\`ere che
cifra e decifra sequenze binarie e dove la chiave, al posto di essere corta e ripetuta, \`e lunga quanto il messaggio
e dunque non \`e mai ripetuta.

La prima parte del nome (One-Time) \`e relativa alla chiave: ogni chiave dev'essere utilizzata una sola volta e poi
buttata via.

\subsubsection{Funzionamento}
Consideriamo
\begin{itemize}
	\item \textbf{MSG}: lo spazio dei messaggi.
	\item \textbf{CRITTO}: lo spazio dei crittogrammi.
	\item \textbf{KEY}: lo spazio delle chiavi.
\end{itemize}
Sia il messaggio, che la chiave, che il crittogramma saranno una sequenza di $n$ bit. Il crittogramma si compone facendo
lo XOR bit a bit di messaggio e chiave
\[ c = m \oplus k \]
Lo XOR ritorna 1 se i bit che sto confrontando sono uguali, ritorna 0 altrimenti. Il crittoanalista, vedendo il
crittogramma, sa che
\begin{itemize}
	\item quando vede uno 0 in posizione $i$, allora i bit di messaggio e chiave in posizione $i$ sono uguali ma
	      non si sa se siano tutti e due 0 o tutti e due 1.
	\item quando vede un 1 in posizione $i$, allora i bit di messaggio e chiave in posizione $i$ sono diversi ma
	      non si sa quale sia 1 e quale sia 0.
\end{itemize}
Per effettuare la decifrazione basta rifare lo XOR bit a bit di crittogramma e chiave
\[ c_i \oplus k_i = m_i \]
si vede facilmente che il procedimento funziona
\begin{gather*}
	c_i = m_i \oplus k_i \\
	\Downarrow \\
	m_i \oplus k_i \oplus k_i = m_i
\end{gather*}
ma $k_i \oplus k_i$ \`e un sequenza di 0 e quindi deduciamo facilmente che
\[ m_i \oplus 0 = m_i \]

\subsubsection{Debolezza}
La debolezza si ha dal punto di vista della generazione delle chiavi. Come abbiamo detto, la chiave dev'essere monouso.

Prendiamo come esempio il caso in cui due messaggi, $m_1$ ed $m_2$ siano cifrati, con la stessa chiave $k$, in due
crittogrammi
\begin{gather*}
	c_1 = m_1 \oplus k \\
	c_2 = m_2 \oplus k
\end{gather*}
A questo punto il crittoanalista potrebbe applicare lo XOR bit a bit fra i due crittogrammi per ottenere
\[ c_1 \oplus c_2 = (m_1 \oplus k) \oplus (m_2 \oplus k) \]
dato che vale la propriet\`a associativa posso scrivere
\[ c_1 \oplus c_2 = (m_1 \oplus m_2) \oplus (k \oplus k) \]
Come prima $k \oplus k$ \`e una sequenza di 0 e quindi otteniamo
\[ c_1 \oplus c_2 = m_1 \oplus m_2 \]
Dalla sequenza di bit ottenuta, si pu\`o raffinare la propria conoscenza del messaggio andando a cercare lunghe sequenze
di 0, le quali indicano che quella parte di messaggio \`e stata inviata due volte.

\subsubsection{Sicurezza}
Vogliamo ora dimostrare che il cifrario \`e perfetto. Per farlo lavoriamo sotto alcune ipotesi
\begin{itemize}
	\item Tutti i messaggi sono lunghi $n$. Se il messaggio \`e pi\`u corto di $n$ faccio un po' di \emph{padding}.
	      Se invece il messaggio \`e pi\`u lungo di $n$ faccio una cifratura a blocchi.
	\item Tutte le sequenze di $n$ bit sono messaggi possibili.
	\item I messaggi privi di significato vengono utilizzati per confondere la crittoanalisi e ognuno di essi ha una
	      probabilit\`a molto bassa, ma comunque maggiore di 0, di essere inviati.
	\item La chiave deve essere casuale e unica per ogni messaggio.
\end{itemize}

\begin{theorem}
	Sotto le ipotesi appena elencate, One-Time Pad \`e un cifrario perfetto e impiega un numero minimo di chiavi.
	\begin{proof}
		Dimostriamo per prima cosa la \textbf{minimalit\`a}, ossia
		\[ N_n = N_k = 2^n \]
		ma questo \`e immediato dato che le chiavi sono sequenze di bit lunghe quanto i messaggi.
	\end{proof}

	\begin{proof}
		Dimostriamo ora che il cifrario \`e perfetto. Come sappiamo, un cifrario \`e perfetto se per ogni $m \in$ MSG e
		per ogni $c \in$ CRITTO vale
		\[ P(M = m \mid C = c) = P(M = m) \]
		Partiamo dicendo che
		\[ P(M = m \mid C = c) = \frac{P(M = m \wedge C = c)}{P(C = c)} \]
		dove il valore al numeratore \`e la probabilit\`a che il messaggio inviato sia $m$ e che sia stato cifrato in $c$.

		Per come \`e fatto lo XOR, fissato $m$, chiavi diverse producono crittogrammi diversi. Esiste dunque
		un'\textbf{unica} chiave $k$ che cifra $m$ in $c$. Pi\`u formalmente possiamo affermare che la probabilit\`a che
		il crittogramma sia $c$ \`e uguale alla probabilit\`a di scegliere a caso l'unica chiave $k$ che cifra $m$ in $c$
		\[ P(C = c) = \frac{1}{2^n} \]
		Se la probabilit\`a di ottenere il crittogramma $c$ dipende solo dalla chiave, allora i due eventi sono al
		numeratore indipendenti e possiamo quindi riscrivere la formula iniziale in questo modo
		\[ P(M = m \mid C = c) = \frac{P(M = m) \cdot P(C = c)}{P(C = c)} \]
		Semplificando \`e immediato ottenere
		\[ P(M = m \mid C = c) = P(M = m) \]
	\end{proof}
\end{theorem}

\subsubsection{Scambio delle chiavi}
Un metodo ragionevole per lo scambio di chiavi \`e quello che prevede lo scambio tra i due utenti del generatore casuale
e del suo assetto iniziale (seme).

In questo modo il procedimento di cifratura e decifrazione funziona in questo modo
\begin{enumerate}
	\item I due generatori vengono impostati allo stesso modo con lo stesso seme.
	\item Si scrive un messaggio $m$ e si genera un chiave $k$ lunga $|m|$ con il generatore.
	\item Si cifra il messaggio con $k$.
	\item Si genera la chiave $k$ di $|c|$ bit con il secondo generatore, che ricordiamo essere uguale al primo e
	      inizializzato con lo stesso seme.
	\item Si decifra il crittogramma $c$ con la chiave $k$ generata dal secondo generatore.
\end{enumerate}
Alla fine di questo processo si ha che i due generatori sono impostati di nuovo alla stessa maniera e si pu\`o quindi
continuare la comunicazione.

Il generatore deve essere crittograficamente sicuro e il seme deve essere molto lungo in modo da essere al riparo da
attacchi a forza bruta sul seme.

\subsubsection{Conclusioni}
In conclusione proviamo a rimuovere l'ipotesi secondo cui ogni messaggio sia possibile, anche quelli non significativi.

Dato che le chiavi devono essere tante quante i messaggi possibili. Se restringessimo l'insieme dei messaggi possibili
anche lo spazio delle chiavi diventerebbe pi\`u piccolo e con esso anche la lunghezza delle chiavi diminuirebbe.

In lingua inglese i messaggi significativi lunghi $n$ bit sono circa $\alpha^n$ con
\[ \alpha = 1.1 \]
Se considerassimo quindi solo l'insieme dei messaggi significativi in inglese, la cardinalit\`a dell'insieme di chiavi
passerebbe da $2^n$ a $1.1^n$.

Il numero delle chiavi dev'essere almeno quanto il numero dei messaggi
\[ N_k \geq N_m = \alpha^n < 2^n \]
e dato che $\alpha^n < 2^n$ posso descrivere le chiavi con $t$ bit con $t$ tale che
\[ 2^t \geq \alpha^n \]
quindi
\[ t \quad \geq \quad n \log_2 \alpha \quad \tilde{=} \quad 0.12 \cdot n \]
Abbiamo cos\`i ridotto il numero di chiavi possibili a circa un decimo del numero di chiavi che avevamo prima.

Il problema \`e che avendo ridotto cos\`i tanto l'insieme delle chiavi, un attacco di tipo forza bruta torna ad avere
senso.

Quello che si fa in genere per riuscire a mitigare il problema riuscendo comunque a diminuire un po' il numero di chiavi
e far s\`i che decifrando un crittogramma con chiavi diverse si riesca a risalire a diversi messaggi significativi.

In altre parole, cifrando messaggi diversi con chiavi diverse si ottiene lo stesso crittogramma.

Per fare questo il numero di coppie $(m, k)$ deve essere molto maggiore del numero di crittogrammi. Supponiamo di usare
chiavi casuali di $t$ bit. Se il numero di messaggi significativi \`e $\alpha^n$ abbiamo
\[ \alpha^n \cdot 2^t \]
possibili coppie $(m, k)$ mentre il numero dei crittogrammi rimane $2^n$. Otteniamo dunque che
\[ \alpha^n \cdot 2^t >> 2^n \]
che equivale a
\[ n \log_2 \alpha + t >> n \]
sviluppando ancora i calcoli otteniamo che le chiavi devono essere lunghe
\[ t >> n - n\log_2 \alpha \quad \rightarrow \quad t >> 0.88 \cdot n \]
affinch\'e si verifichi il fenomeno descritto in precedenza, ossia che a pi\`u coppie messaggio-chiave corrisponda lo
stesso crittogramma.

La rimozione dell'ipotesi non ci permette quindi di risparmiare sui bit della chiave se si vuole mantenere un buon grado
di sicurezza. Siamo comunque riusciti a diminuire il numero delle chiavi.

\section{Cifrari simmetrici per crittografia di massa}
Questi cifrari rientrano nel secondo gruppo di cifrari moderni, non hanno quindi un tipo di sicurezza incondizionata ma
di tipo computazionale.

Nascondono quindi l'informazione a patto che il crittoanalista abbia risorese computazionali limitate e che P $\neq$ NP.

\subsection{Cifrario AES}
Si tratta di un cifrario simmetrico che fa uso di chiavi brevi (128 o 256 bit) e ripetute che deveono essere cambiate
per ogni nuova sessione di comunicazione.

Dato che la chiave \`e corta il messaggio \`e diviso in blocchi lunghi quanto la chiave.

La sicurezza del cifrario sui due \textbf{principi di Shannon} che rendono i due cifrari robusti alla crittoanalisi
statistica. I due principi in questione sono
\begin{itemize}
	\item \textbf{Diffusione}: Il testo in chiaro si deve distribuire su tutto il crittogramma. Ogni carattere del
	      crittogramma deve cio\`e dipendere da tutti i caratteri del blocco del messaggio.

	      Si ottiene cos\`i un istogramma delle frequenze piatto.
	\item \textbf{Confusione}: Messaggio e crittogramma sono combinati fra loro in modo molto complesso per non
	      permettere al crittoanalista di separare le due sequenze tramite l'analisi statistica del crittogramma.

	      Per far s\`i che questo avvenga devono essere vere due condizioni
	      \begin{itemize}
		      \item La chiave deve essere ben distribuita sul testo cifrato.
		      \item Ogni bit del crittogramma deve dipendere da tutti i bit della chiave.
	      \end{itemize}
\end{itemize}

\subsection{Cifrario DES}
\`E stato il primo cifrario \textbf{certificato} proposto da IBM e che proponeva una struttura di questo tipo:
\begin{itemize}
	\item Il messaggio \`e diviso in blocchi, ciascuno cifrato e decifrato indipendetemente dall'altro.
	\item Ogni blocco \`e di 64 bit.
	\item Cifratura e decifrazione procedono in $r$ fasi o \textbf{round} in cui si ripetono le stesse operazioni. Per
	      questo cifrario i round sono 16.
	\item La chiave \`e composta da 8 byte. I primi sette bit di ciascun byte sono scelti arbitrariamente e l'ottavo
	      \`e aggiunto per il controllo di parit\`a.
	      \begin{itemize}
		      \item La chiave contiene dunque 64 bit: 56 arbitrari e 8 di parit\`a.
		      \item Dalla chiave vengono create $r$ \textbf{sottochiavi di fase}.
	      \end{itemize}
\end{itemize}

\subsubsection{Funzionamento}
Sia $m$ il messaggio da inviare, $c$ il rispettivo crittogramma e $k$ la chiave. Il processo di cifratura \`e il seguente
\begin{enumerate}
	\item Il bit del messaggio vengono permutati (blocco PI).
	\item La chiave viene private dei bit di controllo parit\`a e permuta i rimanenti (blocco T).
	\item Si dividono i bit del messaggio in due parti (S e D), ciascuna di 32 bit.
	\item Si entra in un ciclo di 16 fasi e per ogni fase $i$ abbiamo in input, l'output della fase precedente.

	      Alla chiave $k$ si applicano queste operazioni:
	      \begin{itemize}
		      \item I 56 bit della chiave vengono divisi in due parti da 28 bit ciascuna e si applica, a ciascuna delle
		            due parti, uno shift ciclico di 1 o 2 bit a seconda della fase in cui ci si trova.

		            Procedimento necessario affinch\'e vengano usati tutti i bit della chiave.
		      \item Si estraggono 48 bit dai due blocchi di 28 bit del punto precedente che andranno a formare la
		            sottochiave di fase.
		      \item Riconcateno le due sequenze shiftate che andranno poi a comporre la chiave per la fase successiva.
	      \end{itemize}
	      I due blocchi del messaggio vengono trattati in questo modo:
	      \begin{itemize}
		      \item Si mandano i 32 bit di destra (input) nella parte di sinistra (output)
		            \[ S[i] = D[i-1] \]
		      \item Sempre della parte di destra vengono copiati 16 bit andando a produrre un blocco da 48 bit.
		      \item Si fa lo XOR bit a bit tra questo blocco appena prodotto e la sottochiave di fase.
		      \item Il blocco di 48 bit vengono riportati a 32 bit grazie alla \textbf{S-box} (approfondimento pi\`u
		            avanti).
		      \item Si permutano i bit prodotti al passo precedente.
		      \item Si fa lo XOR bit a bit tra il blocco di bit appena prodotto e la parte sinistra in input andando a
		            comporre il nuovo blocco di destra.
	      \end{itemize}
	\item Parte destra e parte sinistra vengono unite di nuovo.
	\item Si permutano i bit del blocco ottenuto (blocco PF).
\end{enumerate}
La S-box \`e una funzione composta da 8 sotto-funzioni, ciascuna che prende in input 6 bit e ne restituisce 4.

Per farlo si prendono il primo e l'ultimo bit in input e se ne ricava un indice di riga mentre con i rimanenti bit
si ricava un indice di colonna.

Tramite questi due indici si ottiene un valore presente in una tabella, le cui righe contengono ognuna una permutazione
dei primi 16 interi, il quale sar\`a resituito in output di 4 bit.

\subsubsection{Sicurezza e attacchi}
Uno degli attacchi di cui il DES \`e stato vittima \`e quello di tipo \textbf{distribuito}, ossia, attacchi di tipo
forza bruta distribuiti su pi\`u macchine i quali sono riusciti a forzare il cifrario in tempi sempre minori.

Analizziamo ora altri tipi di attacchi usati per forzare il DES. Partiamo facendo una premessa: un cifrario ha una
sicurezza di $b$ bit se il costo del miglior attacco \`e di ordine $O(2^b)$ operazioni e richiede di esplorare uno
spazio delle chiavi di cardinalit\`a $2^b$.

Nel caso del DES abbiamo chiavi da 56 bit ma lo spazio delle chiavi ha cardinalit\`a $2^{55}$ dato che se cifriamo
il complemento del messaggio col complemento della chiave otteniamo il complemento del crittogramma. I bit di sicurezza
non sono quindi 56 ma 55.

Questo ha anche un'altra applicazione: se provando una chiave, questa non va bene allora posso escludere anche il suo
complemento.

Un tipo di attacco che si potrebbe decidere di sferrare \`e di tipo \textbf{chosen plain text}.
\begin{enumerate}
	\item Si prende un messaggio $m$ e lo si cifra in $c_1$.
	\item Si cifra in $\overline{m}$ in $c_2$, ossia il complemento di $m$.
	\item Per ogni chiave $k$ si prova a cifrare $m$ con $k$.
	      \begin{itemize}
		      \item Se si ottiene $c_1$ molto probabilmente $k$ \`e la chiave (non sicuramente dato che potrebbero
		            esserci altre chiavi che mappano $m$ in $c_1$).
		      \item Se la cifratura ha invece prodotto $\overline{c_2}$ allora \`e probabile che $\overline{k}$ sia
		            la chiave.

		            Questo perch\'e provando a cifrare il complemento del messaggio col complemento della chiave si
		            ottiene il complemento del crittogramma. Nel nostro caso
		            \[ C(\overline{m}, \overline{k}) = \overline{\overline{c_2}} = c_2 \]
		      \item Altrimenti ne $k$ ne $\overline{k}$ sono le chiavi ma con una sola cifratura vengono scartate
		            due chiavi.
	      \end{itemize}
\end{enumerate}

Un altro attacco di tipo \emph{chosen plain text} si basa sulla \textbf{crittoanalisi differenziale}, la quale necessita
di almeno $2^{47}$ coppie messaggio-crittogramma per funzionare e sfrutta l'analisi probabilistica per stimare quale
chiave \`e stata usata andando a cercare variazioni nei vari crittogrammi.

Il costo di questo attacco \`e tuttavia dell'ordine di $O(2^{55})$ operazioni per via delle 16 fasi del cifrario che
rende l'attacco leggermente pi\`u dispendioso del forza bruta.

L'ultima tecnica di attacco che vediamo \`e basata sulla \textbf{crittoanalisi lineare} ed \`e un attacco di tipo
\emph{know plain text}.

Per effettuare l'attacco si necessita di $2^{43}$ coppie messaggio-crittogramma e serve a stimare alcuni bit della chiave.

Questa tecnica \`e meno costosa del forza bruta e dunque \`e vulnerabile.

\subsubsection{Alternative}
Si \`e provato a cambiare sempre le chiavi di fase, arrivando ad avere 768 bit di chiave complessivi. In realt\`a,
per attacchi basati su crittoanalisi differenziale, i bit di sicurezza sono 61.

Vengono aggiunti solo 6 bit di sicurezza al fronte di una chiave molto pi\`u lunga.

L'approccio che invece \`e stato adottato \`e stata la \textbf{cifratura multipla}, ossia, la composizione del DES con
se stesso. Scelte due chiavi $k_1$ e $k_2$ qualsiasi, vale che
\[ C(C(m, k_1), k_2) \neq C(m, k_3) \]
per qualunque chiave $k_3$ nello spazio delle chiavi. In questo modo otteniamo chiavi di 112 bit ma con 57 bit di
sicurezza.

Ci\`o che riduce molto i bit di sicurezza sono gli attacchi di tipo \textbf{meet in the middle}. Data una coppia
messaggio-crittogramma l'attacco funziona in questo modo:
\begin{enumerate}
	\item Per ogni $k_1$ si calcola e si salva
	      \[ C(m, k_1) \]
	\item Per ogni $k_2$ si calcola
	      \[ D(c, k_2) \]
	      e si cerca nella tabella.
	\item Se troviamo una corrispondenza $k_1$ e $k_2$ probabilmente sono le chiavi.
\end{enumerate}
L'attacco si basa sul fatto che se il crittogramma $c$ \`e generato da
\[ C(C(m, k_1), k_2) \]
allora vale
\[ D(c, k_2) = C(m, k_1) \]
Quello che di fatto andiamo a fare \`e enumerare tutte le chiavi due volte (non tutte le coppie di chiavi) e poi cerchiamo
una corrispondenza.

Se le chiavi sono $2^{56}$ basta moltiplicare per 2 e otteniamo cos\`i $2^{57}$ operazioni per forzare il cifrario.