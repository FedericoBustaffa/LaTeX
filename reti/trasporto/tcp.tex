\section{TCP}
Il protocollo \textbf{TCP} è un tipo di protocollo orientato allo \textbf{stream}. Uno stream è
un flusso di byte la cui lunghezza non si può definire a priori. Le caratteristiche principali di
questo tipo di comunicazione sono:
\begin{itemize}
	\item I byte ricevuti dal destinatario sono esattamente gli stessi che ha inviato il mittente.
	      Senza perdite ne modifiche.
	\item Il protocollo vede il flusso di byte come una sequenza ordinata ma non strutturata di
	      byte.
\end{itemize}
Come già detto si tratta di un servizio connection-oriented con le seguenti caratteristiche:
\begin{itemize}
	\item I processi effetuano un \emph{handshake} prima dello scambio dei dati.
	\item Si dice \textbf{orientato} poiché lo stato della connessione risiede sui nodi terminali
	      e non sui nodi intermedi (router).
	\item La connessione è vista dagli applicativi come un circuito fisico dedicato.
	\item La connessione è di tipo \textbf{full-duplex}: a prescindere da chi invia il messaggio
	      di richiesta per la connessione, una volta instaurata la connessione, questa è
	      bidirezionale.
	\item La connessione è di tipo \textbf{punto-punto} in quanto si vuole connettere solo due
	      sistemi terminali l'un con l'altro.
\end{itemize}
Il trasferimento è inoltre \textbf{bufferizzato}, il software TCP può infatti suddividere il flusso
di byte in segmenti indipendentemente da come gli vengono inviati dal programma applicativo.

Per farlo è necessario un \textbf{buffer} dove immagazzinare le sequenze di byte. Non appena i dati
sono sufficienti per riempire un segmento ragionevolmente grande, questo viene trasmesso attraverso
la rete.

Questo metodo permette di "ottimizzare" il numero di segmenti spediti sulla rete andando a ridurre
di conseguenza il traffico. Permette inoltre di ritrasmettere eventuali segmenti andati persi.

\subsection{Segmenti TCP}
Il flusso di byte viene quindi partizionato in \textbf{segmenti}, ognuno con il proprio header, e
ognuno consegnato a livello IP.

Il protocollo, per garantire che i segmenti siano composti da byte ordinati, numera i byte stessi
con \textbf{numeri di sequenza} e \textbf{numeri di riscontro}.

Ogni segmento possiede un campo che indica il numero di sequenza, ossia il numero del primo byte in
tale segmento.

Il numero di riscontro è il numero dell'ultimo byte correttamente ricevuto più 1. Il numero di
riscontro indica quindi quanti byte sono giunti a destinazione e qual'è il prossimo byte che si è
in attesa di ricevere.

\subsubsection{Formato dei segmenti}
Il formato dei segmenti TCP comprende un \emph{header} e i dati che vogliano inviare. L'header del
segmento, con una lunghezza variabile tra i 20 e i 60 byte contiene:
\begin{itemize}
	\item Porta del sorgente e del destinatario.
	\item Numero di sequenza e di riscontro.
	\item Lunghezza dell'header.
	\item Campi riservati.
	\item Flag: \verb|URG|, \verb|ACK|, \verb|PSH|, \verb|RST|, \verb|SYN| e \verb|FIN|. Di
	      particolare rilevanza sono i flag
	      \begin{itemize}
		      \item \verb|ACK|: se settato a 1 indica che nel campo di riscontro è presente
		            un'informazione significativa.
		      \item \verb|SYN|: sincronizza il numero di sequenza in fase di instaurazione della
				  connessione.
		      \item \verb|FIN|: Indica che non ci sono altri dati in arrivo dal mittente e quindi
		            la connessione può essere chiusa.
	      \end{itemize}
	\item Dimensione della finestra: spazio disponibile nella finestra di ricezione.
	\item Checksum per la verifica dell'integrità.
\end{itemize}

\subsection{Gestione della connessione}
Come già detto, il servizio TCP è un servizio orientato alla connessione. Tale connessione viene 
gestita in tre passi principali:
\begin{itemize}
	\item \textbf{Handshake}: instaurazione della connessione.
	\item \textbf{Trasferimento dati}: gestione del flusso di trasferimento.
	\item \textbf{Chiusura}: come la connessione viene chiusa da entrambi i lati.
\end{itemize}

\subsubsection{Handshake a tre vie}
L'\textbf{handshake} è la fase di instaurazione della connessione. Dopo questa fase non si fa più
distinzione tra client e server in quanto la comunicazione avviene in maniera bidirezionale. In 
questa fase
\begin{enumerate}
	\item Il client invia una richiesta di connessione settando a 1 il flag \verb|SYN| e con un 
		numero di sequenza $n$ generato casualmente.
	\item Se la richiesta di connessione viene accettata il server invia al client un segmento di
		autorizzazione con il flag di \verb|ACK| settato a 1 e con il numero di riscontro uguale
		a $n+1$. Nel segmento inviato sarà inoltre presente il flag \verb|SYN| settato a 1 e un
		nuovo numero di sequenza $m$.
	\item Il client a questo punto invia un messaggio di risposta al messaggio di autorizzazione
		settando il flag di \verb|SYN| a 0, il numero di sequenza a $n+1$ e il campo di riscontro
		a $m+1$.
\end{enumerate}
Questi tre passaggio servono a impostare un tipo di connessione bidirezionale e paritaria tra
client e server. Se svolgessimo solo i primi due passaggi, il client non avrebbe la possibilità
di notificare la disponibilità a ricevere messaggi dal server.

\subsubsection{Chiusura della connessione}
La chiusura della connessione deve avvenire da entrambi i lati, i quali devono essere a conoscenza
del fatto che l'altro sta per chiudere la connessione. Per farlo i due processi si inviano un
segmento con il flag di \verb|FIN| settato a 1 secondo la seguente modalità:
\begin{itemize}
	\item Il client invia un segmento al server con il flag di \verb|FIN| settato a 1 e un numero
		di sequenza $x$.
	\item Il server risponde tramite un segmento con il flag di \verb|ACK| settato a 1 e con il
		campo di riscontro a $x+1$.
	\item Il server può continuare a inviare dati.
	\item Il server invia un segmento con il flag di \verb|FIN| settato a 1 e con un numero di 
		sequenza $y$.
	\item Il client risponde con un segmento di \verb|ACK| e con il campo di riscontro impostato
		a $y+1$.
	\item Il client entra in uno stato di \verb|TIME_WAIT| dalla durata variabile prima di 
		chiudere definitivamente la connessione.
	\item Se il server riceve l'ultimo segmento di \verb|ACK| allora chiude la connessione, 
		altrimenti, dopo un certo timeout, invia di nuovo un segmento con il flag di \verb|FIN|.
	\item Il client, se dopo il timeout, non ha ricevuto ulteriori richieste chiude la
		connessione.
\end{itemize}
Lo stato di \verb|TIME_WAIT| dipende da un altro parametro, ossia il \textbf{MSL} (Maximum Segment
Lifetime). Questo può variare tra le varie implementazioni TCP e indica il tempo massimo che un
pacchetto TCP può rimanere in rete. Dopo quel tempo o è arrivato a destinazione o è stato 
cancellato.

Lo stato di \verb|TIME_WAIT| ha un durata che tipicamente viene calcolata come il doppio del MSL.

Nel caso in cui il client invii il segmento di \verb|FIN| mentre il server sta continuando a 
inviare dati siamo in un stato \textbf{half-close}.

\subsection{Trasferimento dati affidabile}
Un segmento può essere perso o corrotto e TCP implementa un servizio di trasferimento dati 
affidabile per riuscire a contenere queste problematiche.

Per verficare l'integrità del pacchetto esiste un meccanismo di checksum, mentre per stabilire se
qualche pacchetto è andato perso c'è il meccanismo dei \textbf{riscontri} implementato tramite 
numeri di sequenza e di riscontro.

In particolari casi, per esempio con il meccanismo di \textbf{pipeline}, possiamo inviare più 
segmenti senza attendere un loro riscontro.
