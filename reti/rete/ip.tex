\section{IP}
Il \textbf{protocollo IP} (Internet Protocol) è un servizio di tipo connectionless in quanto non
c'è un circuito né logico né fisico tra i due sistemi terminali.

Il servizio offerto non da alcuna garanzia (un po' come UDP) in quanto non vi è alcuna certezza 
che i datagrammi arrivino a destinazione, che siano nello stesso ordine di invio e non vi è alcun
meccanismo di recupero di eventuali datagrammi andati persi.

Quello che fa IP quando riceve un segmento TCP o un datagramma UDP è aggiungere una sua 
intestazione a supporto dell'implementazione dei servizi.

\subsection{Forwarding}
Una delle funzioni principali di IP è l'\textbf{inoltro} (forwarding), ossia il trasferimento del
pacchetto sull'appropriato collegamento in uscita.

Per riuscire a farlo, il router, legge  dall'intestazione, presente all'inizio del datagramma,
l'indirizzo di destinazione. Per riuscire a prendere una decisione sul collegamento di uscita fa 
riferimento ad una \textbf{tabella di inoltro} nella quale è specificata \textbf{ l'interfaccia di
output}.

La tabella di inoltro viene costruita servendosi di una \textbf{funzione di instradamento}, la
quale fa uso di informazioni raccolte attraverso comunicazioni con altri router, per risolvere
un problema decisionale, ossia la scelta di un percorso verso una certa destinazione.

Anche a livello rete si fa Multiplexing e Demultiplexing in quanto nell'header del datagramma
viene codificato il valore del protocollo al quale viene consegnato il payload.

\subsection{Formato del datagramma IP}
Il formato del datagramma IP prevede due parti, l'header e il payload. L'header ha una dimensione
variabile tra 20 e 60 byte e l'intero datagramma può avere una dimensione totale di 65535 byte.
L'header si compone dei seguenti campi:
\begin{itemize}
	\item Versione IP.
	\item Lunghezza header.
	\item Tipo di servizio.
	\item Lunghezza totale del datagram.
	\item Identificativo a 16 bit.
	\item TTL: massimo numero \emph{hop} rimanenti (decrementato ogni volta che passa da un 
		router).
	\item Flag per la frammentazione.
	\item Checksum.
	\item Demultiplexing.
	\item IP mittente e destinatario.
	\item Opzioni.
\end{itemize}
I bit indicati nel campo "tipo di servizio" vanno a supporto del protocollo per indicare le 
caratteristiche del datagramma in base alla \emph{classe} del servizio (telefonata, streaming, 
dati a bassa priorità ecc.) in modo da poter implementare politiche di accodamento diverse.

Alcuni dei bit in questo campo servono a notificare eventi di congestione a livello rete e 
trasporto.

\subsection{Frammentazione}
L'operazione di \textbf{frammentazione} consiste nella suddivisione dei datagrammi IP in 
datagrammi più piccoli, ognuno con la propria intestazione e payload.

Il motivo per cui si ricorre alla frammentazione risiede in un problema dovuto alla capacità del
metodo di collegamento. Quando abbiamo parlato del TCP abbiamo introdotto la Maximum Segment Size,
come la dimensione massima di un segmento TCP tale che possa stare dentro un frame che rispetta il
vincolo di Maximum Transfer Unit, il quale dipende a sua volta dalla tecnologia di collegamento 
che viene utilizzata.

Quando un datagramma IP viaggia sulla rete potrebbe attraverso diversi mezzi di collegamento,
ognuno con un valore di Maximum Transfer Unit differente. Ecco che, se durante il viaggio, il 
datagramma passa da un valore più alto a un più basso di MTU si è costretti a frammentare il 
pacchetto.

Ciascun frammento è a tutti gli effetti un datagramma IP indipendente dagli altri in grado di 
viaggiare su reti fisiche differenti.

I \textbf{campi di frammentazione} nell'header del datagramma IP danno indicazioni su come
frammentare e ricomporre il messaggio. Per ricomporre i frammenti infatti il protocollo IP fa uso
dei campi \textbf{identifactore}, \textbf{flag} e \textbf{offset}:
\begin{itemize}
	\item \textbf{Identificatore}: l'identifactore non dipende dal frammento analizzato ma dal 
		datagramma a cui appartiene tale frammento. In questo modo il frammento è possibile sapere
		quali sono i frammenti che devono essere ricomposti.
	\item \textbf{Offset}: indica la posizione relativa come multiplo di 8 byte in modo da 
		riordinare i frammenti quando necessario.
	\item \textbf{Flag}: campo di 3 bit, ognuno con un significato diverso:
		\begin{itemize}
			\item \emph{Reserved}: sempre a 0 per ora.
			\item \emph{Do not fragment}: vale 0 se il datagramma può essere frammentato, 1 se il
				datagramma non deve essere frammentato.
			\item \emph{More fragments}: vale 0 se il pacchetto è l'ultimo frammento, 1 altrimenti.
		\end{itemize}
\end{itemize}
Visto che la frammentazione è un processo critico, in quanto aumenta la probabilità di perdita di
pacchetta, si è deciso di evitarla. In IPv4 si fa utilizzo del flag \emph{do not fragment} e in
IPv6 non è proprio disponibile.

Nella pratica, quando un router non riesce più ad inoltrare un datagramma, lo comunica al sorgente
che ne invierà uno più piccolo.

In questo modo si aggiunge un po' di carico sui nodi sorgente ma si riesce ad alleggerire di molto
il carico sui vari router e si evita la frammentazione a meno che non sia strettamente necessaria.

\subsection{Indirizzo IPv4}
Ogni host è connesso alla rete tramite un'interfaccia di rete che è il confine tra l'host e il 
collegamento su cui vengono inviati i dati. Ad ogni interfaccia è assegnato un 
\textbf{indirizzo IP}.

Per IPv4 abbiamo 4 byte (32 bit) per la composizione dell'IP. I primi $n$ bit identificano la rete
su internet, mentre i restanti identificano l'host all'interno di tale rete.

\subsubsection{Assegnamento indirizzi}
Si pone il problema di assegnare gli indirizzi IP in modo che non ci siano due host connessi alla
stessa rete con lo stesso IP pubblico.

Si è quindi deciso di suddividere gli indirizzi IP di rete in 5 classi: A, B, C, D, E. Queste 
classi differiscono nel numero di bit che dedicano all'identificativo di rete. La classe A ha meno
bit per l'identificazione delle reti ma ne ha molti per l'identificazione dei vari host.

Questo metodo però è poco flessibile per via dello scarso range di indirizzi disponibili, si è
quindi deciso di rimuovere le classi e passare ad un meccanismo di tipo \textbf{classless 
addressing}.

Questo metodo prevede l'aggiunta di un valore che indica quanti, dei 32 bit disponibili, sono stati
utilizzati per il prefisso.
